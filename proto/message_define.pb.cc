// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message_define.proto

#include "message_define.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace raybo {
PROTOBUF_CONSTEXPR MsgHeader::MsgHeader(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ver_)*/0u
  , /*decltype(_impl_.cmd_type_)*/0u} {}
struct MsgHeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MsgHeaderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MsgHeaderDefaultTypeInternal() {}
  union {
    MsgHeader _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MsgHeaderDefaultTypeInternal _MsgHeader_default_instance_;
PROTOBUF_CONSTEXPR RegReq::RegReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.user_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.password_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.from_)*/0u} {}
struct RegReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RegReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RegReqDefaultTypeInternal() {}
  union {
    RegReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RegReqDefaultTypeInternal _RegReq_default_instance_;
PROTOBUF_CONSTEXPR RegRsp::RegRsp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.ret_)*/0u
  , /*decltype(_impl_.user_id_)*/0u} {}
struct RegRspDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RegRspDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RegRspDefaultTypeInternal() {}
  union {
    RegRsp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RegRspDefaultTypeInternal _RegRsp_default_instance_;
PROTOBUF_CONSTEXPR LoginReq::LoginReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.user_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.password_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ver_)*/0u
  , /*decltype(_impl_.cmd_type_)*/0u} {}
struct LoginReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoginReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoginReqDefaultTypeInternal() {}
  union {
    LoginReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginReqDefaultTypeInternal _LoginReq_default_instance_;
PROTOBUF_CONSTEXPR LoginRsp::LoginRsp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ver_)*/0u
  , /*decltype(_impl_.cmd_type_)*/0u
  , /*decltype(_impl_.ret_)*/0u
  , /*decltype(_impl_.user_id_)*/0u} {}
struct LoginRspDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoginRspDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoginRspDefaultTypeInternal() {}
  union {
    LoginRsp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginRspDefaultTypeInternal _LoginRsp_default_instance_;
PROTOBUF_CONSTEXPR LogoutReq::LogoutReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.user_id_)*/0u} {}
struct LogoutReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LogoutReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LogoutReqDefaultTypeInternal() {}
  union {
    LogoutReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LogoutReqDefaultTypeInternal _LogoutReq_default_instance_;
PROTOBUF_CONSTEXPR LogoutRsp::LogoutRsp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ret_)*/0u} {}
struct LogoutRspDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LogoutRspDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LogoutRspDefaultTypeInternal() {}
  union {
    LogoutRsp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LogoutRspDefaultTypeInternal _LogoutRsp_default_instance_;
PROTOBUF_CONSTEXPR AddFriendReq::AddFriendReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.user_id_)*/0u
  , /*decltype(_impl_.other_id_)*/0u} {}
struct AddFriendReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AddFriendReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AddFriendReqDefaultTypeInternal() {}
  union {
    AddFriendReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AddFriendReqDefaultTypeInternal _AddFriendReq_default_instance_;
PROTOBUF_CONSTEXPR AddFriendRsp::AddFriendRsp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.ret_)*/0u} {}
struct AddFriendRspDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AddFriendRspDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AddFriendRspDefaultTypeInternal() {}
  union {
    AddFriendRsp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AddFriendRspDefaultTypeInternal _AddFriendRsp_default_instance_;
PROTOBUF_CONSTEXPR DelFriendReq::DelFriendReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.user_id_)*/0u
  , /*decltype(_impl_.other_id_)*/0u} {}
struct DelFriendReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DelFriendReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DelFriendReqDefaultTypeInternal() {}
  union {
    DelFriendReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DelFriendReqDefaultTypeInternal _DelFriendReq_default_instance_;
PROTOBUF_CONSTEXPR DelFriendRsp::DelFriendRsp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.ret_)*/0u} {}
struct DelFriendRspDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DelFriendRspDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DelFriendRspDefaultTypeInternal() {}
  union {
    DelFriendRsp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DelFriendRspDefaultTypeInternal _DelFriendRsp_default_instance_;
PROTOBUF_CONSTEXPR PublishMessageReq::PublishMessageReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.content_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.user_id_)*/0u} {}
struct PublishMessageReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PublishMessageReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PublishMessageReqDefaultTypeInternal() {}
  union {
    PublishMessageReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PublishMessageReqDefaultTypeInternal _PublishMessageReq_default_instance_;
PROTOBUF_CONSTEXPR PublishMessageRsp::PublishMessageRsp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.ret_)*/0u} {}
struct PublishMessageRspDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PublishMessageRspDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PublishMessageRspDefaultTypeInternal() {}
  union {
    PublishMessageRsp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PublishMessageRspDefaultTypeInternal _PublishMessageRsp_default_instance_;
PROTOBUF_CONSTEXPR GetMessageListReq::GetMessageListReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.user_id_)*/0u} {}
struct GetMessageListReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetMessageListReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetMessageListReqDefaultTypeInternal() {}
  union {
    GetMessageListReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetMessageListReqDefaultTypeInternal _GetMessageListReq_default_instance_;
PROTOBUF_CONSTEXPR MessageItem::MessageItem(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.content_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.publisher_id_)*/0u
  , /*decltype(_impl_.publish_time_)*/0u} {}
struct MessageItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MessageItemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MessageItemDefaultTypeInternal() {}
  union {
    MessageItem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MessageItemDefaultTypeInternal _MessageItem_default_instance_;
PROTOBUF_CONSTEXPR GetMessageListRsp::GetMessageListRsp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.message_list_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.ret_)*/0u} {}
struct GetMessageListRspDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetMessageListRspDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetMessageListRspDefaultTypeInternal() {}
  union {
    GetMessageListRsp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetMessageListRspDefaultTypeInternal _GetMessageListRsp_default_instance_;
PROTOBUF_CONSTEXPR GetPhotoReq::GetPhotoReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.user_id_)*/0u} {}
struct GetPhotoReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetPhotoReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetPhotoReqDefaultTypeInternal() {}
  union {
    GetPhotoReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetPhotoReqDefaultTypeInternal _GetPhotoReq_default_instance_;
PROTOBUF_CONSTEXPR GetPhotoRsp::GetPhotoRsp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.last_publish_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.ret_)*/0u
  , /*decltype(_impl_.last_publisher_id_)*/0u} {}
struct GetPhotoRspDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetPhotoRspDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetPhotoRspDefaultTypeInternal() {}
  union {
    GetPhotoRsp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetPhotoRspDefaultTypeInternal _GetPhotoRsp_default_instance_;
PROTOBUF_CONSTEXPR CommonReq::CommonReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.reg_req_)*/nullptr
  , /*decltype(_impl_.login_req_)*/nullptr
  , /*decltype(_impl_.logout_req_)*/nullptr
  , /*decltype(_impl_.add_friend_req_)*/nullptr
  , /*decltype(_impl_.del_friend_req_)*/nullptr
  , /*decltype(_impl_.publish_message_req_)*/nullptr
  , /*decltype(_impl_.get_photo_req_)*/nullptr
  , /*decltype(_impl_.get_message_list_req_)*/nullptr} {}
struct CommonReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommonReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommonReqDefaultTypeInternal() {}
  union {
    CommonReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommonReqDefaultTypeInternal _CommonReq_default_instance_;
PROTOBUF_CONSTEXPR CommonRsp::CommonRsp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.reg_rsp_)*/nullptr
  , /*decltype(_impl_.login_rsp_)*/nullptr
  , /*decltype(_impl_.logout_rsp_)*/nullptr
  , /*decltype(_impl_.add_friend_rsp_)*/nullptr
  , /*decltype(_impl_.del_friend_rsp_)*/nullptr
  , /*decltype(_impl_.publish_message_rsp_)*/nullptr
  , /*decltype(_impl_.get_photo_rsp_)*/nullptr
  , /*decltype(_impl_.get_message_list_rsp_)*/nullptr} {}
struct CommonRspDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommonRspDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommonRspDefaultTypeInternal() {}
  union {
    CommonRsp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommonRspDefaultTypeInternal _CommonRsp_default_instance_;
PROTOBUF_CONSTEXPR GetUserIdByNameReq::GetUserIdByNameReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.user_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.header_)*/nullptr} {}
struct GetUserIdByNameReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetUserIdByNameReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetUserIdByNameReqDefaultTypeInternal() {}
  union {
    GetUserIdByNameReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetUserIdByNameReqDefaultTypeInternal _GetUserIdByNameReq_default_instance_;
PROTOBUF_CONSTEXPR GetUserIdByNameRsp::GetUserIdByNameRsp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.ret_)*/0
  , /*decltype(_impl_.user_id_)*/0} {}
struct GetUserIdByNameRspDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetUserIdByNameRspDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetUserIdByNameRspDefaultTypeInternal() {}
  union {
    GetUserIdByNameRsp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetUserIdByNameRspDefaultTypeInternal _GetUserIdByNameRsp_default_instance_;
PROTOBUF_CONSTEXPR CreateUserReq::CreateUserReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.user_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.password_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.from_)*/0} {}
struct CreateUserReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateUserReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateUserReqDefaultTypeInternal() {}
  union {
    CreateUserReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateUserReqDefaultTypeInternal _CreateUserReq_default_instance_;
PROTOBUF_CONSTEXPR CreateUserRsp::CreateUserRsp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.ret_)*/0
  , /*decltype(_impl_.user_id_)*/0} {}
struct CreateUserRspDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateUserRspDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateUserRspDefaultTypeInternal() {}
  union {
    CreateUserRsp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateUserRspDefaultTypeInternal _CreateUserRsp_default_instance_;
PROTOBUF_CONSTEXPR LoginCheckReq::LoginCheckReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.user_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.password_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.header_)*/nullptr} {}
struct LoginCheckReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoginCheckReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoginCheckReqDefaultTypeInternal() {}
  union {
    LoginCheckReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginCheckReqDefaultTypeInternal _LoginCheckReq_default_instance_;
PROTOBUF_CONSTEXPR LoginCheckRsp::LoginCheckRsp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.ret_)*/0
  , /*decltype(_impl_.user_id_)*/0} {}
struct LoginCheckRspDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoginCheckRspDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoginCheckRspDefaultTypeInternal() {}
  union {
    LoginCheckRsp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginCheckRspDefaultTypeInternal _LoginCheckRsp_default_instance_;
PROTOBUF_CONSTEXPR CheckUserExistReq::CheckUserExistReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.user_id_)*/0} {}
struct CheckUserExistReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CheckUserExistReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CheckUserExistReqDefaultTypeInternal() {}
  union {
    CheckUserExistReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CheckUserExistReqDefaultTypeInternal _CheckUserExistReq_default_instance_;
PROTOBUF_CONSTEXPR CheckUserExistRsp::CheckUserExistRsp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.ret_)*/0} {}
struct CheckUserExistRspDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CheckUserExistRspDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CheckUserExistRspDefaultTypeInternal() {}
  union {
    CheckUserExistRsp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CheckUserExistRspDefaultTypeInternal _CheckUserExistRsp_default_instance_;
PROTOBUF_CONSTEXPR ServerToUserReq::ServerToUserReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.get_user_id_)*/nullptr
  , /*decltype(_impl_.create_user_)*/nullptr
  , /*decltype(_impl_.login_check_)*/nullptr
  , /*decltype(_impl_.check_user_exist_)*/nullptr} {}
struct ServerToUserReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServerToUserReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServerToUserReqDefaultTypeInternal() {}
  union {
    ServerToUserReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServerToUserReqDefaultTypeInternal _ServerToUserReq_default_instance_;
PROTOBUF_CONSTEXPR UserToServerRsp::UserToServerRsp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.get_user_id_)*/nullptr
  , /*decltype(_impl_.create_user_)*/nullptr
  , /*decltype(_impl_.login_check_)*/nullptr
  , /*decltype(_impl_.check_user_exist_)*/nullptr} {}
struct UserToServerRspDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserToServerRspDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserToServerRspDefaultTypeInternal() {}
  union {
    UserToServerRsp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserToServerRspDefaultTypeInternal _UserToServerRsp_default_instance_;
}  // namespace raybo
static ::_pb::Metadata file_level_metadata_message_5fdefine_2eproto[30];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_message_5fdefine_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_message_5fdefine_2eproto = nullptr;

const uint32_t TableStruct_message_5fdefine_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::raybo::MsgHeader, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::raybo::MsgHeader, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::raybo::MsgHeader, _impl_.ver_),
  PROTOBUF_FIELD_OFFSET(::raybo::MsgHeader, _impl_.cmd_type_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::raybo::RegReq, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::raybo::RegReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::raybo::RegReq, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::raybo::RegReq, _impl_.user_name_),
  PROTOBUF_FIELD_OFFSET(::raybo::RegReq, _impl_.password_),
  PROTOBUF_FIELD_OFFSET(::raybo::RegReq, _impl_.from_),
  2,
  0,
  1,
  3,
  PROTOBUF_FIELD_OFFSET(::raybo::RegRsp, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::raybo::RegRsp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::raybo::RegRsp, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::raybo::RegRsp, _impl_.ret_),
  PROTOBUF_FIELD_OFFSET(::raybo::RegRsp, _impl_.user_id_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::raybo::LoginReq, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::raybo::LoginReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::raybo::LoginReq, _impl_.ver_),
  PROTOBUF_FIELD_OFFSET(::raybo::LoginReq, _impl_.cmd_type_),
  PROTOBUF_FIELD_OFFSET(::raybo::LoginReq, _impl_.user_name_),
  PROTOBUF_FIELD_OFFSET(::raybo::LoginReq, _impl_.password_),
  2,
  3,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::raybo::LoginRsp, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::raybo::LoginRsp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::raybo::LoginRsp, _impl_.ver_),
  PROTOBUF_FIELD_OFFSET(::raybo::LoginRsp, _impl_.cmd_type_),
  PROTOBUF_FIELD_OFFSET(::raybo::LoginRsp, _impl_.ret_),
  PROTOBUF_FIELD_OFFSET(::raybo::LoginRsp, _impl_.user_id_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::raybo::LogoutReq, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::raybo::LogoutReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::raybo::LogoutReq, _impl_.user_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::raybo::LogoutRsp, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::raybo::LogoutRsp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::raybo::LogoutRsp, _impl_.ret_),
  0,
  PROTOBUF_FIELD_OFFSET(::raybo::AddFriendReq, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::raybo::AddFriendReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::raybo::AddFriendReq, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::raybo::AddFriendReq, _impl_.user_id_),
  PROTOBUF_FIELD_OFFSET(::raybo::AddFriendReq, _impl_.other_id_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::raybo::AddFriendRsp, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::raybo::AddFriendRsp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::raybo::AddFriendRsp, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::raybo::AddFriendRsp, _impl_.ret_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::raybo::DelFriendReq, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::raybo::DelFriendReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::raybo::DelFriendReq, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::raybo::DelFriendReq, _impl_.user_id_),
  PROTOBUF_FIELD_OFFSET(::raybo::DelFriendReq, _impl_.other_id_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::raybo::DelFriendRsp, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::raybo::DelFriendRsp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::raybo::DelFriendRsp, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::raybo::DelFriendRsp, _impl_.ret_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::raybo::PublishMessageReq, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::raybo::PublishMessageReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::raybo::PublishMessageReq, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::raybo::PublishMessageReq, _impl_.user_id_),
  PROTOBUF_FIELD_OFFSET(::raybo::PublishMessageReq, _impl_.content_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::raybo::PublishMessageRsp, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::raybo::PublishMessageRsp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::raybo::PublishMessageRsp, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::raybo::PublishMessageRsp, _impl_.ret_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::raybo::GetMessageListReq, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::raybo::GetMessageListReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::raybo::GetMessageListReq, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::raybo::GetMessageListReq, _impl_.user_id_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::raybo::MessageItem, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::raybo::MessageItem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::raybo::MessageItem, _impl_.publisher_id_),
  PROTOBUF_FIELD_OFFSET(::raybo::MessageItem, _impl_.publish_time_),
  PROTOBUF_FIELD_OFFSET(::raybo::MessageItem, _impl_.content_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::raybo::GetMessageListRsp, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::raybo::GetMessageListRsp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::raybo::GetMessageListRsp, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::raybo::GetMessageListRsp, _impl_.ret_),
  PROTOBUF_FIELD_OFFSET(::raybo::GetMessageListRsp, _impl_.message_list_),
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::raybo::GetPhotoReq, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::raybo::GetPhotoReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::raybo::GetPhotoReq, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::raybo::GetPhotoReq, _impl_.user_id_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::raybo::GetPhotoRsp, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::raybo::GetPhotoRsp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::raybo::GetPhotoRsp, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::raybo::GetPhotoRsp, _impl_.ret_),
  PROTOBUF_FIELD_OFFSET(::raybo::GetPhotoRsp, _impl_.last_publisher_id_),
  PROTOBUF_FIELD_OFFSET(::raybo::GetPhotoRsp, _impl_.last_publish_name_),
  1,
  2,
  3,
  0,
  PROTOBUF_FIELD_OFFSET(::raybo::CommonReq, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::raybo::CommonReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::raybo::CommonReq, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::raybo::CommonReq, _impl_.reg_req_),
  PROTOBUF_FIELD_OFFSET(::raybo::CommonReq, _impl_.login_req_),
  PROTOBUF_FIELD_OFFSET(::raybo::CommonReq, _impl_.logout_req_),
  PROTOBUF_FIELD_OFFSET(::raybo::CommonReq, _impl_.add_friend_req_),
  PROTOBUF_FIELD_OFFSET(::raybo::CommonReq, _impl_.del_friend_req_),
  PROTOBUF_FIELD_OFFSET(::raybo::CommonReq, _impl_.publish_message_req_),
  PROTOBUF_FIELD_OFFSET(::raybo::CommonReq, _impl_.get_photo_req_),
  PROTOBUF_FIELD_OFFSET(::raybo::CommonReq, _impl_.get_message_list_req_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  PROTOBUF_FIELD_OFFSET(::raybo::CommonRsp, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::raybo::CommonRsp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::raybo::CommonRsp, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::raybo::CommonRsp, _impl_.reg_rsp_),
  PROTOBUF_FIELD_OFFSET(::raybo::CommonRsp, _impl_.login_rsp_),
  PROTOBUF_FIELD_OFFSET(::raybo::CommonRsp, _impl_.logout_rsp_),
  PROTOBUF_FIELD_OFFSET(::raybo::CommonRsp, _impl_.add_friend_rsp_),
  PROTOBUF_FIELD_OFFSET(::raybo::CommonRsp, _impl_.del_friend_rsp_),
  PROTOBUF_FIELD_OFFSET(::raybo::CommonRsp, _impl_.publish_message_rsp_),
  PROTOBUF_FIELD_OFFSET(::raybo::CommonRsp, _impl_.get_photo_rsp_),
  PROTOBUF_FIELD_OFFSET(::raybo::CommonRsp, _impl_.get_message_list_rsp_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  PROTOBUF_FIELD_OFFSET(::raybo::GetUserIdByNameReq, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::raybo::GetUserIdByNameReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::raybo::GetUserIdByNameReq, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::raybo::GetUserIdByNameReq, _impl_.user_name_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::raybo::GetUserIdByNameRsp, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::raybo::GetUserIdByNameRsp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::raybo::GetUserIdByNameRsp, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::raybo::GetUserIdByNameRsp, _impl_.ret_),
  PROTOBUF_FIELD_OFFSET(::raybo::GetUserIdByNameRsp, _impl_.user_id_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::raybo::CreateUserReq, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::raybo::CreateUserReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::raybo::CreateUserReq, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::raybo::CreateUserReq, _impl_.user_name_),
  PROTOBUF_FIELD_OFFSET(::raybo::CreateUserReq, _impl_.password_),
  PROTOBUF_FIELD_OFFSET(::raybo::CreateUserReq, _impl_.from_),
  2,
  0,
  1,
  3,
  PROTOBUF_FIELD_OFFSET(::raybo::CreateUserRsp, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::raybo::CreateUserRsp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::raybo::CreateUserRsp, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::raybo::CreateUserRsp, _impl_.ret_),
  PROTOBUF_FIELD_OFFSET(::raybo::CreateUserRsp, _impl_.user_id_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::raybo::LoginCheckReq, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::raybo::LoginCheckReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::raybo::LoginCheckReq, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::raybo::LoginCheckReq, _impl_.user_name_),
  PROTOBUF_FIELD_OFFSET(::raybo::LoginCheckReq, _impl_.password_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::raybo::LoginCheckRsp, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::raybo::LoginCheckRsp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::raybo::LoginCheckRsp, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::raybo::LoginCheckRsp, _impl_.ret_),
  PROTOBUF_FIELD_OFFSET(::raybo::LoginCheckRsp, _impl_.user_id_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::raybo::CheckUserExistReq, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::raybo::CheckUserExistReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::raybo::CheckUserExistReq, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::raybo::CheckUserExistReq, _impl_.user_id_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::raybo::CheckUserExistRsp, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::raybo::CheckUserExistRsp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::raybo::CheckUserExistRsp, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::raybo::CheckUserExistRsp, _impl_.ret_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::raybo::ServerToUserReq, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::raybo::ServerToUserReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::raybo::ServerToUserReq, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::raybo::ServerToUserReq, _impl_.get_user_id_),
  PROTOBUF_FIELD_OFFSET(::raybo::ServerToUserReq, _impl_.create_user_),
  PROTOBUF_FIELD_OFFSET(::raybo::ServerToUserReq, _impl_.login_check_),
  PROTOBUF_FIELD_OFFSET(::raybo::ServerToUserReq, _impl_.check_user_exist_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::raybo::UserToServerRsp, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::raybo::UserToServerRsp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::raybo::UserToServerRsp, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::raybo::UserToServerRsp, _impl_.get_user_id_),
  PROTOBUF_FIELD_OFFSET(::raybo::UserToServerRsp, _impl_.create_user_),
  PROTOBUF_FIELD_OFFSET(::raybo::UserToServerRsp, _impl_.login_check_),
  PROTOBUF_FIELD_OFFSET(::raybo::UserToServerRsp, _impl_.check_user_exist_),
  0,
  1,
  2,
  3,
  4,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, -1, sizeof(::raybo::MsgHeader)},
  { 10, 20, -1, sizeof(::raybo::RegReq)},
  { 24, 33, -1, sizeof(::raybo::RegRsp)},
  { 36, 46, -1, sizeof(::raybo::LoginReq)},
  { 50, 60, -1, sizeof(::raybo::LoginRsp)},
  { 64, 71, -1, sizeof(::raybo::LogoutReq)},
  { 72, 79, -1, sizeof(::raybo::LogoutRsp)},
  { 80, 89, -1, sizeof(::raybo::AddFriendReq)},
  { 92, 100, -1, sizeof(::raybo::AddFriendRsp)},
  { 102, 111, -1, sizeof(::raybo::DelFriendReq)},
  { 114, 122, -1, sizeof(::raybo::DelFriendRsp)},
  { 124, 133, -1, sizeof(::raybo::PublishMessageReq)},
  { 136, 144, -1, sizeof(::raybo::PublishMessageRsp)},
  { 146, 154, -1, sizeof(::raybo::GetMessageListReq)},
  { 156, 165, -1, sizeof(::raybo::MessageItem)},
  { 168, 177, -1, sizeof(::raybo::GetMessageListRsp)},
  { 180, 188, -1, sizeof(::raybo::GetPhotoReq)},
  { 190, 200, -1, sizeof(::raybo::GetPhotoRsp)},
  { 204, 219, -1, sizeof(::raybo::CommonReq)},
  { 228, 243, -1, sizeof(::raybo::CommonRsp)},
  { 252, 260, -1, sizeof(::raybo::GetUserIdByNameReq)},
  { 262, 271, -1, sizeof(::raybo::GetUserIdByNameRsp)},
  { 274, 284, -1, sizeof(::raybo::CreateUserReq)},
  { 288, 297, -1, sizeof(::raybo::CreateUserRsp)},
  { 300, 309, -1, sizeof(::raybo::LoginCheckReq)},
  { 312, 321, -1, sizeof(::raybo::LoginCheckRsp)},
  { 324, 332, -1, sizeof(::raybo::CheckUserExistReq)},
  { 334, 342, -1, sizeof(::raybo::CheckUserExistRsp)},
  { 344, 355, -1, sizeof(::raybo::ServerToUserReq)},
  { 360, 371, -1, sizeof(::raybo::UserToServerRsp)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::raybo::_MsgHeader_default_instance_._instance,
  &::raybo::_RegReq_default_instance_._instance,
  &::raybo::_RegRsp_default_instance_._instance,
  &::raybo::_LoginReq_default_instance_._instance,
  &::raybo::_LoginRsp_default_instance_._instance,
  &::raybo::_LogoutReq_default_instance_._instance,
  &::raybo::_LogoutRsp_default_instance_._instance,
  &::raybo::_AddFriendReq_default_instance_._instance,
  &::raybo::_AddFriendRsp_default_instance_._instance,
  &::raybo::_DelFriendReq_default_instance_._instance,
  &::raybo::_DelFriendRsp_default_instance_._instance,
  &::raybo::_PublishMessageReq_default_instance_._instance,
  &::raybo::_PublishMessageRsp_default_instance_._instance,
  &::raybo::_GetMessageListReq_default_instance_._instance,
  &::raybo::_MessageItem_default_instance_._instance,
  &::raybo::_GetMessageListRsp_default_instance_._instance,
  &::raybo::_GetPhotoReq_default_instance_._instance,
  &::raybo::_GetPhotoRsp_default_instance_._instance,
  &::raybo::_CommonReq_default_instance_._instance,
  &::raybo::_CommonRsp_default_instance_._instance,
  &::raybo::_GetUserIdByNameReq_default_instance_._instance,
  &::raybo::_GetUserIdByNameRsp_default_instance_._instance,
  &::raybo::_CreateUserReq_default_instance_._instance,
  &::raybo::_CreateUserRsp_default_instance_._instance,
  &::raybo::_LoginCheckReq_default_instance_._instance,
  &::raybo::_LoginCheckRsp_default_instance_._instance,
  &::raybo::_CheckUserExistReq_default_instance_._instance,
  &::raybo::_CheckUserExistRsp_default_instance_._instance,
  &::raybo::_ServerToUserReq_default_instance_._instance,
  &::raybo::_UserToServerRsp_default_instance_._instance,
};

const char descriptor_table_protodef_message_5fdefine_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\024message_define.proto\022\005raybo\"I\n\tMsgHead"
  "er\022\020\n\003ver\030\001 \001(\rH\000\210\001\001\022\025\n\010cmd_type\030\002 \001(\rH\001"
  "\210\001\001B\006\n\004_verB\013\n\t_cmd_type\"\240\001\n\006RegReq\022%\n\006h"
  "eader\030\001 \001(\0132\020.raybo.MsgHeaderH\000\210\001\001\022\026\n\tus"
  "er_name\030\003 \001(\tH\001\210\001\001\022\025\n\010password\030\004 \001(\tH\002\210\001"
  "\001\022\021\n\004from\030\005 \001(\rH\003\210\001\001B\t\n\007_headerB\014\n\n_user"
  "_nameB\013\n\t_passwordB\007\n\005_from\"v\n\006RegRsp\022%\n"
  "\006header\030\001 \001(\0132\020.raybo.MsgHeaderH\000\210\001\001\022\020\n\003"
  "ret\030\003 \001(\rH\001\210\001\001\022\024\n\007user_id\030\004 \001(\rH\002\210\001\001B\t\n\007"
  "_headerB\006\n\004_retB\n\n\010_user_id\"\222\001\n\010LoginReq"
  "\022\020\n\003ver\030\001 \001(\rH\000\210\001\001\022\025\n\010cmd_type\030\002 \001(\rH\001\210\001"
  "\001\022\026\n\tuser_name\030\003 \001(\tH\002\210\001\001\022\025\n\010password\030\004 "
  "\001(\tH\003\210\001\001B\006\n\004_verB\013\n\t_cmd_typeB\014\n\n_user_n"
  "ameB\013\n\t_password\"\204\001\n\010LoginRsp\022\020\n\003ver\030\001 \001"
  "(\rH\000\210\001\001\022\025\n\010cmd_type\030\002 \001(\rH\001\210\001\001\022\020\n\003ret\030\003 "
  "\001(\rH\002\210\001\001\022\024\n\007user_id\030\004 \001(\rH\003\210\001\001B\006\n\004_verB\013"
  "\n\t_cmd_typeB\006\n\004_retB\n\n\010_user_id\"-\n\tLogou"
  "tReq\022\024\n\007user_id\030\003 \001(\rH\000\210\001\001B\n\n\010_user_id\"%"
  "\n\tLogoutRsp\022\020\n\003ret\030\002 \001(\rH\000\210\001\001B\006\n\004_ret\"\206\001"
  "\n\014AddFriendReq\022%\n\006header\030\001 \001(\0132\020.raybo.M"
  "sgHeaderH\000\210\001\001\022\024\n\007user_id\030\002 \001(\rH\001\210\001\001\022\025\n\010o"
  "ther_id\030\003 \001(\rH\002\210\001\001B\t\n\007_headerB\n\n\010_user_i"
  "dB\013\n\t_other_id\"Z\n\014AddFriendRsp\022%\n\006header"
  "\030\001 \001(\0132\020.raybo.MsgHeaderH\000\210\001\001\022\020\n\003ret\030\002 \001"
  "(\rH\001\210\001\001B\t\n\007_headerB\006\n\004_ret\"\206\001\n\014DelFriend"
  "Req\022%\n\006header\030\001 \001(\0132\020.raybo.MsgHeaderH\000\210"
  "\001\001\022\024\n\007user_id\030\002 \001(\rH\001\210\001\001\022\025\n\010other_id\030\003 \001"
  "(\rH\002\210\001\001B\t\n\007_headerB\n\n\010_user_idB\013\n\t_other"
  "_id\"Z\n\014DelFriendRsp\022%\n\006header\030\001 \001(\0132\020.ra"
  "ybo.MsgHeaderH\000\210\001\001\022\020\n\003ret\030\002 \001(\rH\001\210\001\001B\t\n\007"
  "_headerB\006\n\004_ret\"\211\001\n\021PublishMessageReq\022%\n"
  "\006header\030\001 \001(\0132\020.raybo.MsgHeaderH\000\210\001\001\022\024\n\007"
  "user_id\030\002 \001(\rH\001\210\001\001\022\024\n\007content\030\003 \001(\tH\002\210\001\001"
  "B\t\n\007_headerB\n\n\010_user_idB\n\n\010_content\"_\n\021P"
  "ublishMessageRsp\022%\n\006header\030\001 \001(\0132\020.raybo"
  ".MsgHeaderH\000\210\001\001\022\020\n\003ret\030\002 \001(\rH\001\210\001\001B\t\n\007_he"
  "aderB\006\n\004_ret\"g\n\021GetMessageListReq\022%\n\006hea"
  "der\030\001 \001(\0132\020.raybo.MsgHeaderH\000\210\001\001\022\024\n\007user"
  "_id\030\002 \001(\rH\001\210\001\001B\t\n\007_headerB\n\n\010_user_id\"\207\001"
  "\n\013MessageItem\022\031\n\014publisher_id\030\001 \001(\rH\000\210\001\001"
  "\022\031\n\014Publish_time\030\002 \001(\rH\001\210\001\001\022\024\n\007content\030\003"
  " \001(\tH\002\210\001\001B\017\n\r_publisher_idB\017\n\r_Publish_t"
  "imeB\n\n\010_content\"\211\001\n\021GetMessageListRsp\022%\n"
  "\006header\030\001 \001(\0132\020.raybo.MsgHeaderH\000\210\001\001\022\020\n\003"
  "ret\030\002 \001(\rH\001\210\001\001\022(\n\014message_list\030\003 \003(\0132\022.r"
  "aybo.MessageItemB\t\n\007_headerB\006\n\004_ret\"a\n\013G"
  "etPhotoReq\022%\n\006header\030\001 \001(\0132\020.raybo.MsgHe"
  "aderH\000\210\001\001\022\024\n\007user_id\030\002 \001(\rH\001\210\001\001B\t\n\007_head"
  "erB\n\n\010_user_id\"\305\001\n\013GetPhotoRsp\022%\n\006header"
  "\030\001 \001(\0132\020.raybo.MsgHeaderH\000\210\001\001\022\020\n\003ret\030\002 \001"
  "(\rH\001\210\001\001\022\036\n\021last_publisher_id\030\003 \001(\rH\002\210\001\001\022"
  "\036\n\021last_publish_name\030\004 \001(\tH\003\210\001\001B\t\n\007_head"
  "erB\006\n\004_retB\024\n\022_last_publisher_idB\024\n\022_las"
  "t_publish_name\"\325\004\n\tCommonReq\022%\n\006header\030\001"
  " \001(\0132\020.raybo.MsgHeaderH\000\210\001\001\022#\n\007reg_req\030\002"
  " \001(\0132\r.raybo.RegReqH\001\210\001\001\022\'\n\tlogin_req\030\003 "
  "\001(\0132\017.raybo.LoginReqH\002\210\001\001\022)\n\nlogout_req\030"
  "\004 \001(\0132\020.raybo.LogoutReqH\003\210\001\001\0220\n\016add_frie"
  "nd_req\030\005 \001(\0132\023.raybo.AddFriendReqH\004\210\001\001\0220"
  "\n\016del_friend_req\030\006 \001(\0132\023.raybo.DelFriend"
  "ReqH\005\210\001\001\022:\n\023publish_message_req\030\007 \001(\0132\030."
  "raybo.PublishMessageReqH\006\210\001\001\022.\n\rget_phot"
  "o_req\030\010 \001(\0132\022.raybo.GetPhotoReqH\007\210\001\001\022;\n\024"
  "get_message_list_req\030\t \001(\0132\030.raybo.GetMe"
  "ssageListReqH\010\210\001\001B\t\n\007_headerB\n\n\010_reg_req"
  "B\014\n\n_login_reqB\r\n\013_logout_reqB\021\n\017_add_fr"
  "iend_reqB\021\n\017_del_friend_reqB\026\n\024_publish_"
  "message_reqB\020\n\016_get_photo_reqB\027\n\025_get_me"
  "ssage_list_req\"\325\004\n\tCommonRsp\022%\n\006header\030\001"
  " \001(\0132\020.raybo.MsgHeaderH\000\210\001\001\022#\n\007reg_rsp\030\002"
  " \001(\0132\r.raybo.RegRspH\001\210\001\001\022\'\n\tlogin_rsp\030\003 "
  "\001(\0132\017.raybo.LoginRspH\002\210\001\001\022)\n\nlogout_rsp\030"
  "\004 \001(\0132\020.raybo.LogoutRspH\003\210\001\001\0220\n\016add_frie"
  "nd_rsp\030\005 \001(\0132\023.raybo.AddFriendRspH\004\210\001\001\0220"
  "\n\016del_friend_rsp\030\006 \001(\0132\023.raybo.DelFriend"
  "RspH\005\210\001\001\022:\n\023publish_message_rsp\030\007 \001(\0132\030."
  "raybo.PublishMessageRspH\006\210\001\001\022.\n\rget_phot"
  "o_rsp\030\010 \001(\0132\022.raybo.GetPhotoRspH\007\210\001\001\022;\n\024"
  "get_message_list_rsp\030\t \001(\0132\030.raybo.GetMe"
  "ssageListRspH\010\210\001\001B\t\n\007_headerB\n\n\010_reg_rsp"
  "B\014\n\n_login_rspB\r\n\013_logout_rspB\021\n\017_add_fr"
  "iend_rspB\021\n\017_del_friend_rspB\026\n\024_publish_"
  "message_rspB\020\n\016_get_photo_rspB\027\n\025_get_me"
  "ssage_list_rsp\"l\n\022GetUserIdByNameReq\022%\n\006"
  "header\030\001 \001(\0132\020.raybo.MsgHeaderH\000\210\001\001\022\026\n\tu"
  "ser_name\030\002 \001(\tH\001\210\001\001B\t\n\007_headerB\014\n\n_user_"
  "name\"\202\001\n\022GetUserIdByNameRsp\022%\n\006header\030\001 "
  "\001(\0132\020.raybo.MsgHeaderH\000\210\001\001\022\020\n\003ret\030\002 \001(\005H"
  "\001\210\001\001\022\024\n\007user_id\030\003 \001(\005H\002\210\001\001B\t\n\007_headerB\006\n"
  "\004_retB\n\n\010_user_id\"\247\001\n\rCreateUserReq\022%\n\006h"
  "eader\030\001 \001(\0132\020.raybo.MsgHeaderH\000\210\001\001\022\026\n\tus"
  "er_name\030\002 \001(\tH\001\210\001\001\022\025\n\010password\030\003 \001(\tH\002\210\001"
  "\001\022\021\n\004from\030\004 \001(\005H\003\210\001\001B\t\n\007_headerB\014\n\n_user"
  "_nameB\013\n\t_passwordB\007\n\005_from\"}\n\rCreateUse"
  "rRsp\022%\n\006header\030\001 \001(\0132\020.raybo.MsgHeaderH\000"
  "\210\001\001\022\020\n\003ret\030\002 \001(\005H\001\210\001\001\022\024\n\007user_id\030\003 \001(\005H\002"
  "\210\001\001B\t\n\007_headerB\006\n\004_retB\n\n\010_user_id\"\213\001\n\rL"
  "oginCheckReq\022%\n\006header\030\001 \001(\0132\020.raybo.Msg"
  "HeaderH\000\210\001\001\022\026\n\tuser_name\030\002 \001(\tH\001\210\001\001\022\025\n\010p"
  "assword\030\003 \001(\tH\002\210\001\001B\t\n\007_headerB\014\n\n_user_n"
  "ameB\013\n\t_password\"}\n\rLoginCheckRsp\022%\n\006hea"
  "der\030\001 \001(\0132\020.raybo.MsgHeaderH\000\210\001\001\022\020\n\003ret\030"
  "\002 \001(\005H\001\210\001\001\022\024\n\007user_id\030\003 \001(\005H\002\210\001\001B\t\n\007_hea"
  "derB\006\n\004_retB\n\n\010_user_id\"g\n\021CheckUserExis"
  "tReq\022%\n\006header\030\001 \001(\0132\020.raybo.MsgHeaderH\000"
  "\210\001\001\022\024\n\007user_id\030\002 \001(\005H\001\210\001\001B\t\n\007_headerB\n\n\010"
  "_user_id\"_\n\021CheckUserExistRsp\022%\n\006header\030"
  "\001 \001(\0132\020.raybo.MsgHeaderH\000\210\001\001\022\020\n\003ret\030\002 \001("
  "\005H\001\210\001\001B\t\n\007_headerB\006\n\004_ret\"\326\002\n\017ServerToUs"
  "erReq\022%\n\006header\030\001 \001(\0132\020.raybo.MsgHeaderH"
  "\000\210\001\001\0223\n\013get_user_id\030\002 \001(\0132\031.raybo.GetUse"
  "rIdByNameReqH\001\210\001\001\022.\n\013create_user\030\003 \001(\0132\024"
  ".raybo.CreateUserReqH\002\210\001\001\022.\n\013login_check"
  "\030\004 \001(\0132\024.raybo.LoginCheckReqH\003\210\001\001\0227\n\020che"
  "ck_user_exist\030\005 \001(\0132\030.raybo.CheckUserExi"
  "stReqH\004\210\001\001B\t\n\007_headerB\016\n\014_get_user_idB\016\n"
  "\014_create_userB\016\n\014_login_checkB\023\n\021_check_"
  "user_exist\"\326\002\n\017UserToServerRsp\022%\n\006header"
  "\030\001 \001(\0132\020.raybo.MsgHeaderH\000\210\001\001\0223\n\013get_use"
  "r_id\030\002 \001(\0132\031.raybo.GetUserIdByNameRspH\001\210"
  "\001\001\022.\n\013create_user\030\003 \001(\0132\024.raybo.CreateUs"
  "erRspH\002\210\001\001\022.\n\013login_check\030\004 \001(\0132\024.raybo."
  "LoginCheckRspH\003\210\001\001\0227\n\020check_user_exist\030\005"
  " \001(\0132\030.raybo.CheckUserExistRspH\004\210\001\001B\t\n\007_"
  "headerB\016\n\014_get_user_idB\016\n\014_create_userB\016"
  "\n\014_login_checkB\023\n\021_check_user_existb\006pro"
  "to3"
  ;
static ::_pbi::once_flag descriptor_table_message_5fdefine_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_message_5fdefine_2eproto = {
    false, false, 5043, descriptor_table_protodef_message_5fdefine_2eproto,
    "message_define.proto",
    &descriptor_table_message_5fdefine_2eproto_once, nullptr, 0, 30,
    schemas, file_default_instances, TableStruct_message_5fdefine_2eproto::offsets,
    file_level_metadata_message_5fdefine_2eproto, file_level_enum_descriptors_message_5fdefine_2eproto,
    file_level_service_descriptors_message_5fdefine_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_message_5fdefine_2eproto_getter() {
  return &descriptor_table_message_5fdefine_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_message_5fdefine_2eproto(&descriptor_table_message_5fdefine_2eproto);
namespace raybo {

// ===================================================================

class MsgHeader::_Internal {
 public:
  using HasBits = decltype(std::declval<MsgHeader>()._impl_._has_bits_);
  static void set_has_ver(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cmd_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

MsgHeader::MsgHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:raybo.MsgHeader)
}
MsgHeader::MsgHeader(const MsgHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ver_){}
    , decltype(_impl_.cmd_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.ver_, &from._impl_.ver_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.cmd_type_) -
    reinterpret_cast<char*>(&_impl_.ver_)) + sizeof(_impl_.cmd_type_));
  // @@protoc_insertion_point(copy_constructor:raybo.MsgHeader)
}

inline void MsgHeader::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ver_){0u}
    , decltype(_impl_.cmd_type_){0u}
  };
}

MsgHeader::~MsgHeader() {
  // @@protoc_insertion_point(destructor:raybo.MsgHeader)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MsgHeader::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MsgHeader::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MsgHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:raybo.MsgHeader)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.ver_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.cmd_type_) -
        reinterpret_cast<char*>(&_impl_.ver_)) + sizeof(_impl_.cmd_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MsgHeader::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 ver = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ver(&has_bits);
          _impl_.ver_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 cmd_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_cmd_type(&has_bits);
          _impl_.cmd_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MsgHeader::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:raybo.MsgHeader)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional uint32 ver = 1;
  if (_internal_has_ver()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_ver(), target);
  }

  // optional uint32 cmd_type = 2;
  if (_internal_has_cmd_type()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_cmd_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:raybo.MsgHeader)
  return target;
}

size_t MsgHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:raybo.MsgHeader)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 ver = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ver());
    }

    // optional uint32 cmd_type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_cmd_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MsgHeader::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MsgHeader::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MsgHeader::GetClassData() const { return &_class_data_; }

void MsgHeader::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<MsgHeader *>(to)->MergeFrom(
      static_cast<const MsgHeader &>(from));
}


void MsgHeader::MergeFrom(const MsgHeader& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:raybo.MsgHeader)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.ver_ = from._impl_.ver_;
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.cmd_type_ = from._impl_.cmd_type_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MsgHeader::CopyFrom(const MsgHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:raybo.MsgHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgHeader::IsInitialized() const {
  return true;
}

void MsgHeader::InternalSwap(MsgHeader* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MsgHeader, _impl_.cmd_type_)
      + sizeof(MsgHeader::_impl_.cmd_type_)
      - PROTOBUF_FIELD_OFFSET(MsgHeader, _impl_.ver_)>(
          reinterpret_cast<char*>(&_impl_.ver_),
          reinterpret_cast<char*>(&other->_impl_.ver_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MsgHeader::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_message_5fdefine_2eproto_getter, &descriptor_table_message_5fdefine_2eproto_once,
      file_level_metadata_message_5fdefine_2eproto[0]);
}

// ===================================================================

class RegReq::_Internal {
 public:
  using HasBits = decltype(std::declval<RegReq>()._impl_._has_bits_);
  static const ::raybo::MsgHeader& header(const RegReq* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_user_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_password(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_from(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::raybo::MsgHeader&
RegReq::_Internal::header(const RegReq* msg) {
  return *msg->_impl_.header_;
}
RegReq::RegReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:raybo.RegReq)
}
RegReq::RegReq(const RegReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_name_){}
    , decltype(_impl_.password_){}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.from_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.user_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_name()) {
    _impl_.user_name_.Set(from._internal_user_name(), 
      GetArenaForAllocation());
  }
  _impl_.password_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.password_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_password()) {
    _impl_.password_.Set(from._internal_password(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_header()) {
    _impl_.header_ = new ::raybo::MsgHeader(*from._impl_.header_);
  }
  _impl_.from_ = from._impl_.from_;
  // @@protoc_insertion_point(copy_constructor:raybo.RegReq)
}

inline void RegReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_name_){}
    , decltype(_impl_.password_){}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.from_){0u}
  };
  _impl_.user_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.password_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.password_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RegReq::~RegReq() {
  // @@protoc_insertion_point(destructor:raybo.RegReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RegReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.user_name_.Destroy();
  _impl_.password_.Destroy();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void RegReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RegReq::Clear() {
// @@protoc_insertion_point(message_clear_start:raybo.RegReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.user_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.password_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.header_ != nullptr);
      _impl_.header_->Clear();
    }
  }
  _impl_.from_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RegReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .raybo.MsgHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string user_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_user_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "raybo.RegReq.user_name"));
        } else
          goto handle_unusual;
        continue;
      // optional string password = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_password();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "raybo.RegReq.password"));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 from = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_from(&has_bits);
          _impl_.from_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RegReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:raybo.RegReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .raybo.MsgHeader header = 1;
  if (_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // optional string user_name = 3;
  if (_internal_has_user_name()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_user_name().data(), static_cast<int>(this->_internal_user_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "raybo.RegReq.user_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_user_name(), target);
  }

  // optional string password = 4;
  if (_internal_has_password()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_password().data(), static_cast<int>(this->_internal_password().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "raybo.RegReq.password");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_password(), target);
  }

  // optional uint32 from = 5;
  if (_internal_has_from()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_from(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:raybo.RegReq)
  return target;
}

size_t RegReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:raybo.RegReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string user_name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_name());
    }

    // optional string password = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_password());
    }

    // optional .raybo.MsgHeader header = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.header_);
    }

    // optional uint32 from = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_from());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RegReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RegReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RegReq::GetClassData() const { return &_class_data_; }

void RegReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RegReq *>(to)->MergeFrom(
      static_cast<const RegReq &>(from));
}


void RegReq::MergeFrom(const RegReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:raybo.RegReq)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_user_name(from._internal_user_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_password(from._internal_password());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_header()->::raybo::MsgHeader::MergeFrom(from._internal_header());
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.from_ = from._impl_.from_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RegReq::CopyFrom(const RegReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:raybo.RegReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegReq::IsInitialized() const {
  return true;
}

void RegReq::InternalSwap(RegReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_name_, lhs_arena,
      &other->_impl_.user_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.password_, lhs_arena,
      &other->_impl_.password_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RegReq, _impl_.from_)
      + sizeof(RegReq::_impl_.from_)
      - PROTOBUF_FIELD_OFFSET(RegReq, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RegReq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_message_5fdefine_2eproto_getter, &descriptor_table_message_5fdefine_2eproto_once,
      file_level_metadata_message_5fdefine_2eproto[1]);
}

// ===================================================================

class RegRsp::_Internal {
 public:
  using HasBits = decltype(std::declval<RegRsp>()._impl_._has_bits_);
  static const ::raybo::MsgHeader& header(const RegRsp* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::raybo::MsgHeader&
RegRsp::_Internal::header(const RegRsp* msg) {
  return *msg->_impl_.header_;
}
RegRsp::RegRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:raybo.RegRsp)
}
RegRsp::RegRsp(const RegRsp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.ret_){}
    , decltype(_impl_.user_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _impl_.header_ = new ::raybo::MsgHeader(*from._impl_.header_);
  }
  ::memcpy(&_impl_.ret_, &from._impl_.ret_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.user_id_) -
    reinterpret_cast<char*>(&_impl_.ret_)) + sizeof(_impl_.user_id_));
  // @@protoc_insertion_point(copy_constructor:raybo.RegRsp)
}

inline void RegRsp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.ret_){0u}
    , decltype(_impl_.user_id_){0u}
  };
}

RegRsp::~RegRsp() {
  // @@protoc_insertion_point(destructor:raybo.RegRsp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RegRsp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
}

void RegRsp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RegRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:raybo.RegRsp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.ret_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.user_id_) -
        reinterpret_cast<char*>(&_impl_.ret_)) + sizeof(_impl_.user_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RegRsp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .raybo.MsgHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ret = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_ret(&has_bits);
          _impl_.ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 user_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_user_id(&has_bits);
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RegRsp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:raybo.RegRsp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .raybo.MsgHeader header = 1;
  if (_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // optional uint32 ret = 3;
  if (_internal_has_ret()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_ret(), target);
  }

  // optional uint32 user_id = 4;
  if (_internal_has_user_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_user_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:raybo.RegRsp)
  return target;
}

size_t RegRsp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:raybo.RegRsp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .raybo.MsgHeader header = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.header_);
    }

    // optional uint32 ret = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ret());
    }

    // optional uint32 user_id = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RegRsp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RegRsp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RegRsp::GetClassData() const { return &_class_data_; }

void RegRsp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RegRsp *>(to)->MergeFrom(
      static_cast<const RegRsp &>(from));
}


void RegRsp::MergeFrom(const RegRsp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:raybo.RegRsp)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_header()->::raybo::MsgHeader::MergeFrom(from._internal_header());
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.ret_ = from._impl_.ret_;
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.user_id_ = from._impl_.user_id_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RegRsp::CopyFrom(const RegRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:raybo.RegRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegRsp::IsInitialized() const {
  return true;
}

void RegRsp::InternalSwap(RegRsp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RegRsp, _impl_.user_id_)
      + sizeof(RegRsp::_impl_.user_id_)
      - PROTOBUF_FIELD_OFFSET(RegRsp, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RegRsp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_message_5fdefine_2eproto_getter, &descriptor_table_message_5fdefine_2eproto_once,
      file_level_metadata_message_5fdefine_2eproto[2]);
}

// ===================================================================

class LoginReq::_Internal {
 public:
  using HasBits = decltype(std::declval<LoginReq>()._impl_._has_bits_);
  static void set_has_ver(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_cmd_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_user_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_password(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

LoginReq::LoginReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:raybo.LoginReq)
}
LoginReq::LoginReq(const LoginReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_name_){}
    , decltype(_impl_.password_){}
    , decltype(_impl_.ver_){}
    , decltype(_impl_.cmd_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.user_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_name()) {
    _impl_.user_name_.Set(from._internal_user_name(), 
      GetArenaForAllocation());
  }
  _impl_.password_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.password_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_password()) {
    _impl_.password_.Set(from._internal_password(), 
      GetArenaForAllocation());
  }
  ::memcpy(&_impl_.ver_, &from._impl_.ver_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.cmd_type_) -
    reinterpret_cast<char*>(&_impl_.ver_)) + sizeof(_impl_.cmd_type_));
  // @@protoc_insertion_point(copy_constructor:raybo.LoginReq)
}

inline void LoginReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_name_){}
    , decltype(_impl_.password_){}
    , decltype(_impl_.ver_){0u}
    , decltype(_impl_.cmd_type_){0u}
  };
  _impl_.user_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.password_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.password_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LoginReq::~LoginReq() {
  // @@protoc_insertion_point(destructor:raybo.LoginReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoginReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.user_name_.Destroy();
  _impl_.password_.Destroy();
}

void LoginReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LoginReq::Clear() {
// @@protoc_insertion_point(message_clear_start:raybo.LoginReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.user_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.password_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.ver_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.cmd_type_) -
        reinterpret_cast<char*>(&_impl_.ver_)) + sizeof(_impl_.cmd_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LoginReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 ver = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ver(&has_bits);
          _impl_.ver_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 cmd_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_cmd_type(&has_bits);
          _impl_.cmd_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string user_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_user_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "raybo.LoginReq.user_name"));
        } else
          goto handle_unusual;
        continue;
      // optional string password = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_password();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "raybo.LoginReq.password"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoginReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:raybo.LoginReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional uint32 ver = 1;
  if (_internal_has_ver()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_ver(), target);
  }

  // optional uint32 cmd_type = 2;
  if (_internal_has_cmd_type()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_cmd_type(), target);
  }

  // optional string user_name = 3;
  if (_internal_has_user_name()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_user_name().data(), static_cast<int>(this->_internal_user_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "raybo.LoginReq.user_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_user_name(), target);
  }

  // optional string password = 4;
  if (_internal_has_password()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_password().data(), static_cast<int>(this->_internal_password().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "raybo.LoginReq.password");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_password(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:raybo.LoginReq)
  return target;
}

size_t LoginReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:raybo.LoginReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string user_name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_name());
    }

    // optional string password = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_password());
    }

    // optional uint32 ver = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ver());
    }

    // optional uint32 cmd_type = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_cmd_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LoginReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LoginReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LoginReq::GetClassData() const { return &_class_data_; }

void LoginReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LoginReq *>(to)->MergeFrom(
      static_cast<const LoginReq &>(from));
}


void LoginReq::MergeFrom(const LoginReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:raybo.LoginReq)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_user_name(from._internal_user_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_password(from._internal_password());
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.ver_ = from._impl_.ver_;
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.cmd_type_ = from._impl_.cmd_type_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LoginReq::CopyFrom(const LoginReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:raybo.LoginReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginReq::IsInitialized() const {
  return true;
}

void LoginReq::InternalSwap(LoginReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_name_, lhs_arena,
      &other->_impl_.user_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.password_, lhs_arena,
      &other->_impl_.password_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LoginReq, _impl_.cmd_type_)
      + sizeof(LoginReq::_impl_.cmd_type_)
      - PROTOBUF_FIELD_OFFSET(LoginReq, _impl_.ver_)>(
          reinterpret_cast<char*>(&_impl_.ver_),
          reinterpret_cast<char*>(&other->_impl_.ver_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LoginReq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_message_5fdefine_2eproto_getter, &descriptor_table_message_5fdefine_2eproto_once,
      file_level_metadata_message_5fdefine_2eproto[3]);
}

// ===================================================================

class LoginRsp::_Internal {
 public:
  using HasBits = decltype(std::declval<LoginRsp>()._impl_._has_bits_);
  static void set_has_ver(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cmd_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

LoginRsp::LoginRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:raybo.LoginRsp)
}
LoginRsp::LoginRsp(const LoginRsp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ver_){}
    , decltype(_impl_.cmd_type_){}
    , decltype(_impl_.ret_){}
    , decltype(_impl_.user_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.ver_, &from._impl_.ver_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.user_id_) -
    reinterpret_cast<char*>(&_impl_.ver_)) + sizeof(_impl_.user_id_));
  // @@protoc_insertion_point(copy_constructor:raybo.LoginRsp)
}

inline void LoginRsp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ver_){0u}
    , decltype(_impl_.cmd_type_){0u}
    , decltype(_impl_.ret_){0u}
    , decltype(_impl_.user_id_){0u}
  };
}

LoginRsp::~LoginRsp() {
  // @@protoc_insertion_point(destructor:raybo.LoginRsp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoginRsp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LoginRsp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LoginRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:raybo.LoginRsp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.ver_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.user_id_) -
        reinterpret_cast<char*>(&_impl_.ver_)) + sizeof(_impl_.user_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LoginRsp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 ver = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ver(&has_bits);
          _impl_.ver_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 cmd_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_cmd_type(&has_bits);
          _impl_.cmd_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ret = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_ret(&has_bits);
          _impl_.ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 user_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_user_id(&has_bits);
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoginRsp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:raybo.LoginRsp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional uint32 ver = 1;
  if (_internal_has_ver()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_ver(), target);
  }

  // optional uint32 cmd_type = 2;
  if (_internal_has_cmd_type()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_cmd_type(), target);
  }

  // optional uint32 ret = 3;
  if (_internal_has_ret()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_ret(), target);
  }

  // optional uint32 user_id = 4;
  if (_internal_has_user_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_user_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:raybo.LoginRsp)
  return target;
}

size_t LoginRsp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:raybo.LoginRsp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint32 ver = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ver());
    }

    // optional uint32 cmd_type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_cmd_type());
    }

    // optional uint32 ret = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ret());
    }

    // optional uint32 user_id = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LoginRsp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LoginRsp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LoginRsp::GetClassData() const { return &_class_data_; }

void LoginRsp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LoginRsp *>(to)->MergeFrom(
      static_cast<const LoginRsp &>(from));
}


void LoginRsp::MergeFrom(const LoginRsp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:raybo.LoginRsp)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.ver_ = from._impl_.ver_;
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.cmd_type_ = from._impl_.cmd_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.ret_ = from._impl_.ret_;
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.user_id_ = from._impl_.user_id_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LoginRsp::CopyFrom(const LoginRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:raybo.LoginRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginRsp::IsInitialized() const {
  return true;
}

void LoginRsp::InternalSwap(LoginRsp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LoginRsp, _impl_.user_id_)
      + sizeof(LoginRsp::_impl_.user_id_)
      - PROTOBUF_FIELD_OFFSET(LoginRsp, _impl_.ver_)>(
          reinterpret_cast<char*>(&_impl_.ver_),
          reinterpret_cast<char*>(&other->_impl_.ver_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LoginRsp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_message_5fdefine_2eproto_getter, &descriptor_table_message_5fdefine_2eproto_once,
      file_level_metadata_message_5fdefine_2eproto[4]);
}

// ===================================================================

class LogoutReq::_Internal {
 public:
  using HasBits = decltype(std::declval<LogoutReq>()._impl_._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

LogoutReq::LogoutReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:raybo.LogoutReq)
}
LogoutReq::LogoutReq(const LogoutReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.user_id_ = from._impl_.user_id_;
  // @@protoc_insertion_point(copy_constructor:raybo.LogoutReq)
}

inline void LogoutReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_id_){0u}
  };
}

LogoutReq::~LogoutReq() {
  // @@protoc_insertion_point(destructor:raybo.LogoutReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LogoutReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LogoutReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LogoutReq::Clear() {
// @@protoc_insertion_point(message_clear_start:raybo.LogoutReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.user_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LogoutReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 user_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_user_id(&has_bits);
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LogoutReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:raybo.LogoutReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional uint32 user_id = 3;
  if (_internal_has_user_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_user_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:raybo.LogoutReq)
  return target;
}

size_t LogoutReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:raybo.LogoutReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 user_id = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LogoutReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LogoutReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LogoutReq::GetClassData() const { return &_class_data_; }

void LogoutReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LogoutReq *>(to)->MergeFrom(
      static_cast<const LogoutReq &>(from));
}


void LogoutReq::MergeFrom(const LogoutReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:raybo.LogoutReq)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_user_id()) {
    _internal_set_user_id(from._internal_user_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LogoutReq::CopyFrom(const LogoutReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:raybo.LogoutReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogoutReq::IsInitialized() const {
  return true;
}

void LogoutReq::InternalSwap(LogoutReq* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.user_id_, other->_impl_.user_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LogoutReq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_message_5fdefine_2eproto_getter, &descriptor_table_message_5fdefine_2eproto_once,
      file_level_metadata_message_5fdefine_2eproto[5]);
}

// ===================================================================

class LogoutRsp::_Internal {
 public:
  using HasBits = decltype(std::declval<LogoutRsp>()._impl_._has_bits_);
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

LogoutRsp::LogoutRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:raybo.LogoutRsp)
}
LogoutRsp::LogoutRsp(const LogoutRsp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ret_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ret_ = from._impl_.ret_;
  // @@protoc_insertion_point(copy_constructor:raybo.LogoutRsp)
}

inline void LogoutRsp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ret_){0u}
  };
}

LogoutRsp::~LogoutRsp() {
  // @@protoc_insertion_point(destructor:raybo.LogoutRsp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LogoutRsp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LogoutRsp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LogoutRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:raybo.LogoutRsp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ret_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LogoutRsp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 ret = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ret(&has_bits);
          _impl_.ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LogoutRsp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:raybo.LogoutRsp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional uint32 ret = 2;
  if (_internal_has_ret()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_ret(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:raybo.LogoutRsp)
  return target;
}

size_t LogoutRsp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:raybo.LogoutRsp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 ret = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ret());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LogoutRsp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LogoutRsp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LogoutRsp::GetClassData() const { return &_class_data_; }

void LogoutRsp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LogoutRsp *>(to)->MergeFrom(
      static_cast<const LogoutRsp &>(from));
}


void LogoutRsp::MergeFrom(const LogoutRsp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:raybo.LogoutRsp)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_ret()) {
    _internal_set_ret(from._internal_ret());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LogoutRsp::CopyFrom(const LogoutRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:raybo.LogoutRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogoutRsp::IsInitialized() const {
  return true;
}

void LogoutRsp::InternalSwap(LogoutRsp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.ret_, other->_impl_.ret_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LogoutRsp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_message_5fdefine_2eproto_getter, &descriptor_table_message_5fdefine_2eproto_once,
      file_level_metadata_message_5fdefine_2eproto[6]);
}

// ===================================================================

class AddFriendReq::_Internal {
 public:
  using HasBits = decltype(std::declval<AddFriendReq>()._impl_._has_bits_);
  static const ::raybo::MsgHeader& header(const AddFriendReq* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_other_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::raybo::MsgHeader&
AddFriendReq::_Internal::header(const AddFriendReq* msg) {
  return *msg->_impl_.header_;
}
AddFriendReq::AddFriendReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:raybo.AddFriendReq)
}
AddFriendReq::AddFriendReq(const AddFriendReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.user_id_){}
    , decltype(_impl_.other_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _impl_.header_ = new ::raybo::MsgHeader(*from._impl_.header_);
  }
  ::memcpy(&_impl_.user_id_, &from._impl_.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.other_id_) -
    reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.other_id_));
  // @@protoc_insertion_point(copy_constructor:raybo.AddFriendReq)
}

inline void AddFriendReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.user_id_){0u}
    , decltype(_impl_.other_id_){0u}
  };
}

AddFriendReq::~AddFriendReq() {
  // @@protoc_insertion_point(destructor:raybo.AddFriendReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AddFriendReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
}

void AddFriendReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AddFriendReq::Clear() {
// @@protoc_insertion_point(message_clear_start:raybo.AddFriendReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.user_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.other_id_) -
        reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.other_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AddFriendReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .raybo.MsgHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 user_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_user_id(&has_bits);
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 other_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_other_id(&has_bits);
          _impl_.other_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AddFriendReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:raybo.AddFriendReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .raybo.MsgHeader header = 1;
  if (_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // optional uint32 user_id = 2;
  if (_internal_has_user_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_user_id(), target);
  }

  // optional uint32 other_id = 3;
  if (_internal_has_other_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_other_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:raybo.AddFriendReq)
  return target;
}

size_t AddFriendReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:raybo.AddFriendReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .raybo.MsgHeader header = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.header_);
    }

    // optional uint32 user_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
    }

    // optional uint32 other_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_other_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AddFriendReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AddFriendReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AddFriendReq::GetClassData() const { return &_class_data_; }

void AddFriendReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AddFriendReq *>(to)->MergeFrom(
      static_cast<const AddFriendReq &>(from));
}


void AddFriendReq::MergeFrom(const AddFriendReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:raybo.AddFriendReq)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_header()->::raybo::MsgHeader::MergeFrom(from._internal_header());
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.user_id_ = from._impl_.user_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.other_id_ = from._impl_.other_id_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AddFriendReq::CopyFrom(const AddFriendReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:raybo.AddFriendReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddFriendReq::IsInitialized() const {
  return true;
}

void AddFriendReq::InternalSwap(AddFriendReq* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AddFriendReq, _impl_.other_id_)
      + sizeof(AddFriendReq::_impl_.other_id_)
      - PROTOBUF_FIELD_OFFSET(AddFriendReq, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AddFriendReq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_message_5fdefine_2eproto_getter, &descriptor_table_message_5fdefine_2eproto_once,
      file_level_metadata_message_5fdefine_2eproto[7]);
}

// ===================================================================

class AddFriendRsp::_Internal {
 public:
  using HasBits = decltype(std::declval<AddFriendRsp>()._impl_._has_bits_);
  static const ::raybo::MsgHeader& header(const AddFriendRsp* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::raybo::MsgHeader&
AddFriendRsp::_Internal::header(const AddFriendRsp* msg) {
  return *msg->_impl_.header_;
}
AddFriendRsp::AddFriendRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:raybo.AddFriendRsp)
}
AddFriendRsp::AddFriendRsp(const AddFriendRsp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.ret_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _impl_.header_ = new ::raybo::MsgHeader(*from._impl_.header_);
  }
  _impl_.ret_ = from._impl_.ret_;
  // @@protoc_insertion_point(copy_constructor:raybo.AddFriendRsp)
}

inline void AddFriendRsp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.ret_){0u}
  };
}

AddFriendRsp::~AddFriendRsp() {
  // @@protoc_insertion_point(destructor:raybo.AddFriendRsp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AddFriendRsp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
}

void AddFriendRsp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AddFriendRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:raybo.AddFriendRsp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_.ret_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AddFriendRsp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .raybo.MsgHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ret = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ret(&has_bits);
          _impl_.ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AddFriendRsp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:raybo.AddFriendRsp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .raybo.MsgHeader header = 1;
  if (_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // optional uint32 ret = 2;
  if (_internal_has_ret()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_ret(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:raybo.AddFriendRsp)
  return target;
}

size_t AddFriendRsp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:raybo.AddFriendRsp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .raybo.MsgHeader header = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.header_);
    }

    // optional uint32 ret = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ret());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AddFriendRsp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AddFriendRsp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AddFriendRsp::GetClassData() const { return &_class_data_; }

void AddFriendRsp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AddFriendRsp *>(to)->MergeFrom(
      static_cast<const AddFriendRsp &>(from));
}


void AddFriendRsp::MergeFrom(const AddFriendRsp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:raybo.AddFriendRsp)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_header()->::raybo::MsgHeader::MergeFrom(from._internal_header());
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.ret_ = from._impl_.ret_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AddFriendRsp::CopyFrom(const AddFriendRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:raybo.AddFriendRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddFriendRsp::IsInitialized() const {
  return true;
}

void AddFriendRsp::InternalSwap(AddFriendRsp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AddFriendRsp, _impl_.ret_)
      + sizeof(AddFriendRsp::_impl_.ret_)
      - PROTOBUF_FIELD_OFFSET(AddFriendRsp, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AddFriendRsp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_message_5fdefine_2eproto_getter, &descriptor_table_message_5fdefine_2eproto_once,
      file_level_metadata_message_5fdefine_2eproto[8]);
}

// ===================================================================

class DelFriendReq::_Internal {
 public:
  using HasBits = decltype(std::declval<DelFriendReq>()._impl_._has_bits_);
  static const ::raybo::MsgHeader& header(const DelFriendReq* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_other_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::raybo::MsgHeader&
DelFriendReq::_Internal::header(const DelFriendReq* msg) {
  return *msg->_impl_.header_;
}
DelFriendReq::DelFriendReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:raybo.DelFriendReq)
}
DelFriendReq::DelFriendReq(const DelFriendReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.user_id_){}
    , decltype(_impl_.other_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _impl_.header_ = new ::raybo::MsgHeader(*from._impl_.header_);
  }
  ::memcpy(&_impl_.user_id_, &from._impl_.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.other_id_) -
    reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.other_id_));
  // @@protoc_insertion_point(copy_constructor:raybo.DelFriendReq)
}

inline void DelFriendReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.user_id_){0u}
    , decltype(_impl_.other_id_){0u}
  };
}

DelFriendReq::~DelFriendReq() {
  // @@protoc_insertion_point(destructor:raybo.DelFriendReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DelFriendReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
}

void DelFriendReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DelFriendReq::Clear() {
// @@protoc_insertion_point(message_clear_start:raybo.DelFriendReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.user_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.other_id_) -
        reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.other_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DelFriendReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .raybo.MsgHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 user_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_user_id(&has_bits);
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 other_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_other_id(&has_bits);
          _impl_.other_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DelFriendReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:raybo.DelFriendReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .raybo.MsgHeader header = 1;
  if (_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // optional uint32 user_id = 2;
  if (_internal_has_user_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_user_id(), target);
  }

  // optional uint32 other_id = 3;
  if (_internal_has_other_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_other_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:raybo.DelFriendReq)
  return target;
}

size_t DelFriendReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:raybo.DelFriendReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .raybo.MsgHeader header = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.header_);
    }

    // optional uint32 user_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
    }

    // optional uint32 other_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_other_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DelFriendReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DelFriendReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DelFriendReq::GetClassData() const { return &_class_data_; }

void DelFriendReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DelFriendReq *>(to)->MergeFrom(
      static_cast<const DelFriendReq &>(from));
}


void DelFriendReq::MergeFrom(const DelFriendReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:raybo.DelFriendReq)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_header()->::raybo::MsgHeader::MergeFrom(from._internal_header());
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.user_id_ = from._impl_.user_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.other_id_ = from._impl_.other_id_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DelFriendReq::CopyFrom(const DelFriendReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:raybo.DelFriendReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DelFriendReq::IsInitialized() const {
  return true;
}

void DelFriendReq::InternalSwap(DelFriendReq* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DelFriendReq, _impl_.other_id_)
      + sizeof(DelFriendReq::_impl_.other_id_)
      - PROTOBUF_FIELD_OFFSET(DelFriendReq, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DelFriendReq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_message_5fdefine_2eproto_getter, &descriptor_table_message_5fdefine_2eproto_once,
      file_level_metadata_message_5fdefine_2eproto[9]);
}

// ===================================================================

class DelFriendRsp::_Internal {
 public:
  using HasBits = decltype(std::declval<DelFriendRsp>()._impl_._has_bits_);
  static const ::raybo::MsgHeader& header(const DelFriendRsp* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::raybo::MsgHeader&
DelFriendRsp::_Internal::header(const DelFriendRsp* msg) {
  return *msg->_impl_.header_;
}
DelFriendRsp::DelFriendRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:raybo.DelFriendRsp)
}
DelFriendRsp::DelFriendRsp(const DelFriendRsp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.ret_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _impl_.header_ = new ::raybo::MsgHeader(*from._impl_.header_);
  }
  _impl_.ret_ = from._impl_.ret_;
  // @@protoc_insertion_point(copy_constructor:raybo.DelFriendRsp)
}

inline void DelFriendRsp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.ret_){0u}
  };
}

DelFriendRsp::~DelFriendRsp() {
  // @@protoc_insertion_point(destructor:raybo.DelFriendRsp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DelFriendRsp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
}

void DelFriendRsp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DelFriendRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:raybo.DelFriendRsp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_.ret_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DelFriendRsp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .raybo.MsgHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ret = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ret(&has_bits);
          _impl_.ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DelFriendRsp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:raybo.DelFriendRsp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .raybo.MsgHeader header = 1;
  if (_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // optional uint32 ret = 2;
  if (_internal_has_ret()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_ret(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:raybo.DelFriendRsp)
  return target;
}

size_t DelFriendRsp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:raybo.DelFriendRsp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .raybo.MsgHeader header = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.header_);
    }

    // optional uint32 ret = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ret());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DelFriendRsp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DelFriendRsp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DelFriendRsp::GetClassData() const { return &_class_data_; }

void DelFriendRsp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DelFriendRsp *>(to)->MergeFrom(
      static_cast<const DelFriendRsp &>(from));
}


void DelFriendRsp::MergeFrom(const DelFriendRsp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:raybo.DelFriendRsp)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_header()->::raybo::MsgHeader::MergeFrom(from._internal_header());
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.ret_ = from._impl_.ret_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DelFriendRsp::CopyFrom(const DelFriendRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:raybo.DelFriendRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DelFriendRsp::IsInitialized() const {
  return true;
}

void DelFriendRsp::InternalSwap(DelFriendRsp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DelFriendRsp, _impl_.ret_)
      + sizeof(DelFriendRsp::_impl_.ret_)
      - PROTOBUF_FIELD_OFFSET(DelFriendRsp, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DelFriendRsp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_message_5fdefine_2eproto_getter, &descriptor_table_message_5fdefine_2eproto_once,
      file_level_metadata_message_5fdefine_2eproto[10]);
}

// ===================================================================

class PublishMessageReq::_Internal {
 public:
  using HasBits = decltype(std::declval<PublishMessageReq>()._impl_._has_bits_);
  static const ::raybo::MsgHeader& header(const PublishMessageReq* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_content(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::raybo::MsgHeader&
PublishMessageReq::_Internal::header(const PublishMessageReq* msg) {
  return *msg->_impl_.header_;
}
PublishMessageReq::PublishMessageReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:raybo.PublishMessageReq)
}
PublishMessageReq::PublishMessageReq(const PublishMessageReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.content_){}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.user_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.content_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.content_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_content()) {
    _impl_.content_.Set(from._internal_content(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_header()) {
    _impl_.header_ = new ::raybo::MsgHeader(*from._impl_.header_);
  }
  _impl_.user_id_ = from._impl_.user_id_;
  // @@protoc_insertion_point(copy_constructor:raybo.PublishMessageReq)
}

inline void PublishMessageReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.content_){}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.user_id_){0u}
  };
  _impl_.content_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.content_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PublishMessageReq::~PublishMessageReq() {
  // @@protoc_insertion_point(destructor:raybo.PublishMessageReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PublishMessageReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.content_.Destroy();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void PublishMessageReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PublishMessageReq::Clear() {
// @@protoc_insertion_point(message_clear_start:raybo.PublishMessageReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.content_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.header_ != nullptr);
      _impl_.header_->Clear();
    }
  }
  _impl_.user_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PublishMessageReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .raybo.MsgHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 user_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_user_id(&has_bits);
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string content = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_content();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "raybo.PublishMessageReq.content"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PublishMessageReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:raybo.PublishMessageReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .raybo.MsgHeader header = 1;
  if (_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // optional uint32 user_id = 2;
  if (_internal_has_user_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_user_id(), target);
  }

  // optional string content = 3;
  if (_internal_has_content()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_content().data(), static_cast<int>(this->_internal_content().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "raybo.PublishMessageReq.content");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_content(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:raybo.PublishMessageReq)
  return target;
}

size_t PublishMessageReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:raybo.PublishMessageReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string content = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_content());
    }

    // optional .raybo.MsgHeader header = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.header_);
    }

    // optional uint32 user_id = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PublishMessageReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PublishMessageReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PublishMessageReq::GetClassData() const { return &_class_data_; }

void PublishMessageReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<PublishMessageReq *>(to)->MergeFrom(
      static_cast<const PublishMessageReq &>(from));
}


void PublishMessageReq::MergeFrom(const PublishMessageReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:raybo.PublishMessageReq)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_content(from._internal_content());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_header()->::raybo::MsgHeader::MergeFrom(from._internal_header());
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.user_id_ = from._impl_.user_id_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PublishMessageReq::CopyFrom(const PublishMessageReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:raybo.PublishMessageReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PublishMessageReq::IsInitialized() const {
  return true;
}

void PublishMessageReq::InternalSwap(PublishMessageReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.content_, lhs_arena,
      &other->_impl_.content_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PublishMessageReq, _impl_.user_id_)
      + sizeof(PublishMessageReq::_impl_.user_id_)
      - PROTOBUF_FIELD_OFFSET(PublishMessageReq, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PublishMessageReq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_message_5fdefine_2eproto_getter, &descriptor_table_message_5fdefine_2eproto_once,
      file_level_metadata_message_5fdefine_2eproto[11]);
}

// ===================================================================

class PublishMessageRsp::_Internal {
 public:
  using HasBits = decltype(std::declval<PublishMessageRsp>()._impl_._has_bits_);
  static const ::raybo::MsgHeader& header(const PublishMessageRsp* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::raybo::MsgHeader&
PublishMessageRsp::_Internal::header(const PublishMessageRsp* msg) {
  return *msg->_impl_.header_;
}
PublishMessageRsp::PublishMessageRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:raybo.PublishMessageRsp)
}
PublishMessageRsp::PublishMessageRsp(const PublishMessageRsp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.ret_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _impl_.header_ = new ::raybo::MsgHeader(*from._impl_.header_);
  }
  _impl_.ret_ = from._impl_.ret_;
  // @@protoc_insertion_point(copy_constructor:raybo.PublishMessageRsp)
}

inline void PublishMessageRsp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.ret_){0u}
  };
}

PublishMessageRsp::~PublishMessageRsp() {
  // @@protoc_insertion_point(destructor:raybo.PublishMessageRsp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PublishMessageRsp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
}

void PublishMessageRsp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PublishMessageRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:raybo.PublishMessageRsp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_.ret_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PublishMessageRsp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .raybo.MsgHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ret = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ret(&has_bits);
          _impl_.ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PublishMessageRsp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:raybo.PublishMessageRsp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .raybo.MsgHeader header = 1;
  if (_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // optional uint32 ret = 2;
  if (_internal_has_ret()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_ret(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:raybo.PublishMessageRsp)
  return target;
}

size_t PublishMessageRsp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:raybo.PublishMessageRsp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .raybo.MsgHeader header = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.header_);
    }

    // optional uint32 ret = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ret());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PublishMessageRsp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PublishMessageRsp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PublishMessageRsp::GetClassData() const { return &_class_data_; }

void PublishMessageRsp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<PublishMessageRsp *>(to)->MergeFrom(
      static_cast<const PublishMessageRsp &>(from));
}


void PublishMessageRsp::MergeFrom(const PublishMessageRsp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:raybo.PublishMessageRsp)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_header()->::raybo::MsgHeader::MergeFrom(from._internal_header());
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.ret_ = from._impl_.ret_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PublishMessageRsp::CopyFrom(const PublishMessageRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:raybo.PublishMessageRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PublishMessageRsp::IsInitialized() const {
  return true;
}

void PublishMessageRsp::InternalSwap(PublishMessageRsp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PublishMessageRsp, _impl_.ret_)
      + sizeof(PublishMessageRsp::_impl_.ret_)
      - PROTOBUF_FIELD_OFFSET(PublishMessageRsp, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PublishMessageRsp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_message_5fdefine_2eproto_getter, &descriptor_table_message_5fdefine_2eproto_once,
      file_level_metadata_message_5fdefine_2eproto[12]);
}

// ===================================================================

class GetMessageListReq::_Internal {
 public:
  using HasBits = decltype(std::declval<GetMessageListReq>()._impl_._has_bits_);
  static const ::raybo::MsgHeader& header(const GetMessageListReq* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::raybo::MsgHeader&
GetMessageListReq::_Internal::header(const GetMessageListReq* msg) {
  return *msg->_impl_.header_;
}
GetMessageListReq::GetMessageListReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:raybo.GetMessageListReq)
}
GetMessageListReq::GetMessageListReq(const GetMessageListReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.user_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _impl_.header_ = new ::raybo::MsgHeader(*from._impl_.header_);
  }
  _impl_.user_id_ = from._impl_.user_id_;
  // @@protoc_insertion_point(copy_constructor:raybo.GetMessageListReq)
}

inline void GetMessageListReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.user_id_){0u}
  };
}

GetMessageListReq::~GetMessageListReq() {
  // @@protoc_insertion_point(destructor:raybo.GetMessageListReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetMessageListReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
}

void GetMessageListReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetMessageListReq::Clear() {
// @@protoc_insertion_point(message_clear_start:raybo.GetMessageListReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_.user_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetMessageListReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .raybo.MsgHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 user_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_user_id(&has_bits);
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetMessageListReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:raybo.GetMessageListReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .raybo.MsgHeader header = 1;
  if (_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // optional uint32 user_id = 2;
  if (_internal_has_user_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_user_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:raybo.GetMessageListReq)
  return target;
}

size_t GetMessageListReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:raybo.GetMessageListReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .raybo.MsgHeader header = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.header_);
    }

    // optional uint32 user_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetMessageListReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetMessageListReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetMessageListReq::GetClassData() const { return &_class_data_; }

void GetMessageListReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GetMessageListReq *>(to)->MergeFrom(
      static_cast<const GetMessageListReq &>(from));
}


void GetMessageListReq::MergeFrom(const GetMessageListReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:raybo.GetMessageListReq)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_header()->::raybo::MsgHeader::MergeFrom(from._internal_header());
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.user_id_ = from._impl_.user_id_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetMessageListReq::CopyFrom(const GetMessageListReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:raybo.GetMessageListReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetMessageListReq::IsInitialized() const {
  return true;
}

void GetMessageListReq::InternalSwap(GetMessageListReq* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetMessageListReq, _impl_.user_id_)
      + sizeof(GetMessageListReq::_impl_.user_id_)
      - PROTOBUF_FIELD_OFFSET(GetMessageListReq, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GetMessageListReq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_message_5fdefine_2eproto_getter, &descriptor_table_message_5fdefine_2eproto_once,
      file_level_metadata_message_5fdefine_2eproto[13]);
}

// ===================================================================

class MessageItem::_Internal {
 public:
  using HasBits = decltype(std::declval<MessageItem>()._impl_._has_bits_);
  static void set_has_publisher_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_publish_time(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_content(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

MessageItem::MessageItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:raybo.MessageItem)
}
MessageItem::MessageItem(const MessageItem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.content_){}
    , decltype(_impl_.publisher_id_){}
    , decltype(_impl_.publish_time_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.content_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.content_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_content()) {
    _impl_.content_.Set(from._internal_content(), 
      GetArenaForAllocation());
  }
  ::memcpy(&_impl_.publisher_id_, &from._impl_.publisher_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.publish_time_) -
    reinterpret_cast<char*>(&_impl_.publisher_id_)) + sizeof(_impl_.publish_time_));
  // @@protoc_insertion_point(copy_constructor:raybo.MessageItem)
}

inline void MessageItem::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.content_){}
    , decltype(_impl_.publisher_id_){0u}
    , decltype(_impl_.publish_time_){0u}
  };
  _impl_.content_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.content_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MessageItem::~MessageItem() {
  // @@protoc_insertion_point(destructor:raybo.MessageItem)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MessageItem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.content_.Destroy();
}

void MessageItem::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MessageItem::Clear() {
// @@protoc_insertion_point(message_clear_start:raybo.MessageItem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.content_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.publisher_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.publish_time_) -
        reinterpret_cast<char*>(&_impl_.publisher_id_)) + sizeof(_impl_.publish_time_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MessageItem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 publisher_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_publisher_id(&has_bits);
          _impl_.publisher_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 Publish_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_publish_time(&has_bits);
          _impl_.publish_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string content = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_content();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "raybo.MessageItem.content"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MessageItem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:raybo.MessageItem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional uint32 publisher_id = 1;
  if (_internal_has_publisher_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_publisher_id(), target);
  }

  // optional uint32 Publish_time = 2;
  if (_internal_has_publish_time()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_publish_time(), target);
  }

  // optional string content = 3;
  if (_internal_has_content()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_content().data(), static_cast<int>(this->_internal_content().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "raybo.MessageItem.content");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_content(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:raybo.MessageItem)
  return target;
}

size_t MessageItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:raybo.MessageItem)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string content = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_content());
    }

    // optional uint32 publisher_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_publisher_id());
    }

    // optional uint32 Publish_time = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_publish_time());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MessageItem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MessageItem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MessageItem::GetClassData() const { return &_class_data_; }

void MessageItem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<MessageItem *>(to)->MergeFrom(
      static_cast<const MessageItem &>(from));
}


void MessageItem::MergeFrom(const MessageItem& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:raybo.MessageItem)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_content(from._internal_content());
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.publisher_id_ = from._impl_.publisher_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.publish_time_ = from._impl_.publish_time_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MessageItem::CopyFrom(const MessageItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:raybo.MessageItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MessageItem::IsInitialized() const {
  return true;
}

void MessageItem::InternalSwap(MessageItem* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.content_, lhs_arena,
      &other->_impl_.content_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MessageItem, _impl_.publish_time_)
      + sizeof(MessageItem::_impl_.publish_time_)
      - PROTOBUF_FIELD_OFFSET(MessageItem, _impl_.publisher_id_)>(
          reinterpret_cast<char*>(&_impl_.publisher_id_),
          reinterpret_cast<char*>(&other->_impl_.publisher_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MessageItem::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_message_5fdefine_2eproto_getter, &descriptor_table_message_5fdefine_2eproto_once,
      file_level_metadata_message_5fdefine_2eproto[14]);
}

// ===================================================================

class GetMessageListRsp::_Internal {
 public:
  using HasBits = decltype(std::declval<GetMessageListRsp>()._impl_._has_bits_);
  static const ::raybo::MsgHeader& header(const GetMessageListRsp* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::raybo::MsgHeader&
GetMessageListRsp::_Internal::header(const GetMessageListRsp* msg) {
  return *msg->_impl_.header_;
}
GetMessageListRsp::GetMessageListRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:raybo.GetMessageListRsp)
}
GetMessageListRsp::GetMessageListRsp(const GetMessageListRsp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_list_){from._impl_.message_list_}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.ret_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _impl_.header_ = new ::raybo::MsgHeader(*from._impl_.header_);
  }
  _impl_.ret_ = from._impl_.ret_;
  // @@protoc_insertion_point(copy_constructor:raybo.GetMessageListRsp)
}

inline void GetMessageListRsp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_list_){arena}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.ret_){0u}
  };
}

GetMessageListRsp::~GetMessageListRsp() {
  // @@protoc_insertion_point(destructor:raybo.GetMessageListRsp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetMessageListRsp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_list_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void GetMessageListRsp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetMessageListRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:raybo.GetMessageListRsp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.message_list_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_.ret_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetMessageListRsp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .raybo.MsgHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ret = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ret(&has_bits);
          _impl_.ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .raybo.MessageItem message_list = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_message_list(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetMessageListRsp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:raybo.GetMessageListRsp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .raybo.MsgHeader header = 1;
  if (_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // optional uint32 ret = 2;
  if (_internal_has_ret()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_ret(), target);
  }

  // repeated .raybo.MessageItem message_list = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_message_list_size()); i < n; i++) {
    const auto& repfield = this->_internal_message_list(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:raybo.GetMessageListRsp)
  return target;
}

size_t GetMessageListRsp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:raybo.GetMessageListRsp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .raybo.MessageItem message_list = 3;
  total_size += 1UL * this->_internal_message_list_size();
  for (const auto& msg : this->_impl_.message_list_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .raybo.MsgHeader header = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.header_);
    }

    // optional uint32 ret = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ret());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetMessageListRsp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetMessageListRsp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetMessageListRsp::GetClassData() const { return &_class_data_; }

void GetMessageListRsp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GetMessageListRsp *>(to)->MergeFrom(
      static_cast<const GetMessageListRsp &>(from));
}


void GetMessageListRsp::MergeFrom(const GetMessageListRsp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:raybo.GetMessageListRsp)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _impl_.message_list_.MergeFrom(from._impl_.message_list_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_header()->::raybo::MsgHeader::MergeFrom(from._internal_header());
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.ret_ = from._impl_.ret_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetMessageListRsp::CopyFrom(const GetMessageListRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:raybo.GetMessageListRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetMessageListRsp::IsInitialized() const {
  return true;
}

void GetMessageListRsp::InternalSwap(GetMessageListRsp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.message_list_.InternalSwap(&other->_impl_.message_list_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetMessageListRsp, _impl_.ret_)
      + sizeof(GetMessageListRsp::_impl_.ret_)
      - PROTOBUF_FIELD_OFFSET(GetMessageListRsp, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GetMessageListRsp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_message_5fdefine_2eproto_getter, &descriptor_table_message_5fdefine_2eproto_once,
      file_level_metadata_message_5fdefine_2eproto[15]);
}

// ===================================================================

class GetPhotoReq::_Internal {
 public:
  using HasBits = decltype(std::declval<GetPhotoReq>()._impl_._has_bits_);
  static const ::raybo::MsgHeader& header(const GetPhotoReq* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::raybo::MsgHeader&
GetPhotoReq::_Internal::header(const GetPhotoReq* msg) {
  return *msg->_impl_.header_;
}
GetPhotoReq::GetPhotoReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:raybo.GetPhotoReq)
}
GetPhotoReq::GetPhotoReq(const GetPhotoReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.user_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _impl_.header_ = new ::raybo::MsgHeader(*from._impl_.header_);
  }
  _impl_.user_id_ = from._impl_.user_id_;
  // @@protoc_insertion_point(copy_constructor:raybo.GetPhotoReq)
}

inline void GetPhotoReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.user_id_){0u}
  };
}

GetPhotoReq::~GetPhotoReq() {
  // @@protoc_insertion_point(destructor:raybo.GetPhotoReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetPhotoReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
}

void GetPhotoReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetPhotoReq::Clear() {
// @@protoc_insertion_point(message_clear_start:raybo.GetPhotoReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_.user_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetPhotoReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .raybo.MsgHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 user_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_user_id(&has_bits);
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetPhotoReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:raybo.GetPhotoReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .raybo.MsgHeader header = 1;
  if (_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // optional uint32 user_id = 2;
  if (_internal_has_user_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_user_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:raybo.GetPhotoReq)
  return target;
}

size_t GetPhotoReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:raybo.GetPhotoReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .raybo.MsgHeader header = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.header_);
    }

    // optional uint32 user_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetPhotoReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetPhotoReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetPhotoReq::GetClassData() const { return &_class_data_; }

void GetPhotoReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GetPhotoReq *>(to)->MergeFrom(
      static_cast<const GetPhotoReq &>(from));
}


void GetPhotoReq::MergeFrom(const GetPhotoReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:raybo.GetPhotoReq)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_header()->::raybo::MsgHeader::MergeFrom(from._internal_header());
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.user_id_ = from._impl_.user_id_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetPhotoReq::CopyFrom(const GetPhotoReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:raybo.GetPhotoReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetPhotoReq::IsInitialized() const {
  return true;
}

void GetPhotoReq::InternalSwap(GetPhotoReq* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetPhotoReq, _impl_.user_id_)
      + sizeof(GetPhotoReq::_impl_.user_id_)
      - PROTOBUF_FIELD_OFFSET(GetPhotoReq, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GetPhotoReq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_message_5fdefine_2eproto_getter, &descriptor_table_message_5fdefine_2eproto_once,
      file_level_metadata_message_5fdefine_2eproto[16]);
}

// ===================================================================

class GetPhotoRsp::_Internal {
 public:
  using HasBits = decltype(std::declval<GetPhotoRsp>()._impl_._has_bits_);
  static const ::raybo::MsgHeader& header(const GetPhotoRsp* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_last_publisher_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_last_publish_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::raybo::MsgHeader&
GetPhotoRsp::_Internal::header(const GetPhotoRsp* msg) {
  return *msg->_impl_.header_;
}
GetPhotoRsp::GetPhotoRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:raybo.GetPhotoRsp)
}
GetPhotoRsp::GetPhotoRsp(const GetPhotoRsp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.last_publish_name_){}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.ret_){}
    , decltype(_impl_.last_publisher_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.last_publish_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.last_publish_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_last_publish_name()) {
    _impl_.last_publish_name_.Set(from._internal_last_publish_name(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_header()) {
    _impl_.header_ = new ::raybo::MsgHeader(*from._impl_.header_);
  }
  ::memcpy(&_impl_.ret_, &from._impl_.ret_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.last_publisher_id_) -
    reinterpret_cast<char*>(&_impl_.ret_)) + sizeof(_impl_.last_publisher_id_));
  // @@protoc_insertion_point(copy_constructor:raybo.GetPhotoRsp)
}

inline void GetPhotoRsp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.last_publish_name_){}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.ret_){0u}
    , decltype(_impl_.last_publisher_id_){0u}
  };
  _impl_.last_publish_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.last_publish_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetPhotoRsp::~GetPhotoRsp() {
  // @@protoc_insertion_point(destructor:raybo.GetPhotoRsp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetPhotoRsp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.last_publish_name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void GetPhotoRsp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetPhotoRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:raybo.GetPhotoRsp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.last_publish_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.header_ != nullptr);
      _impl_.header_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.ret_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.last_publisher_id_) -
        reinterpret_cast<char*>(&_impl_.ret_)) + sizeof(_impl_.last_publisher_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetPhotoRsp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .raybo.MsgHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ret = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ret(&has_bits);
          _impl_.ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 last_publisher_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_last_publisher_id(&has_bits);
          _impl_.last_publisher_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string last_publish_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_last_publish_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "raybo.GetPhotoRsp.last_publish_name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetPhotoRsp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:raybo.GetPhotoRsp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .raybo.MsgHeader header = 1;
  if (_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // optional uint32 ret = 2;
  if (_internal_has_ret()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_ret(), target);
  }

  // optional uint32 last_publisher_id = 3;
  if (_internal_has_last_publisher_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_last_publisher_id(), target);
  }

  // optional string last_publish_name = 4;
  if (_internal_has_last_publish_name()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_last_publish_name().data(), static_cast<int>(this->_internal_last_publish_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "raybo.GetPhotoRsp.last_publish_name");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_last_publish_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:raybo.GetPhotoRsp)
  return target;
}

size_t GetPhotoRsp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:raybo.GetPhotoRsp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string last_publish_name = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_last_publish_name());
    }

    // optional .raybo.MsgHeader header = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.header_);
    }

    // optional uint32 ret = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ret());
    }

    // optional uint32 last_publisher_id = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_last_publisher_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetPhotoRsp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetPhotoRsp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetPhotoRsp::GetClassData() const { return &_class_data_; }

void GetPhotoRsp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GetPhotoRsp *>(to)->MergeFrom(
      static_cast<const GetPhotoRsp &>(from));
}


void GetPhotoRsp::MergeFrom(const GetPhotoRsp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:raybo.GetPhotoRsp)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_last_publish_name(from._internal_last_publish_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_header()->::raybo::MsgHeader::MergeFrom(from._internal_header());
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.ret_ = from._impl_.ret_;
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.last_publisher_id_ = from._impl_.last_publisher_id_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetPhotoRsp::CopyFrom(const GetPhotoRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:raybo.GetPhotoRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetPhotoRsp::IsInitialized() const {
  return true;
}

void GetPhotoRsp::InternalSwap(GetPhotoRsp* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.last_publish_name_, lhs_arena,
      &other->_impl_.last_publish_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetPhotoRsp, _impl_.last_publisher_id_)
      + sizeof(GetPhotoRsp::_impl_.last_publisher_id_)
      - PROTOBUF_FIELD_OFFSET(GetPhotoRsp, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GetPhotoRsp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_message_5fdefine_2eproto_getter, &descriptor_table_message_5fdefine_2eproto_once,
      file_level_metadata_message_5fdefine_2eproto[17]);
}

// ===================================================================

class CommonReq::_Internal {
 public:
  using HasBits = decltype(std::declval<CommonReq>()._impl_._has_bits_);
  static const ::raybo::MsgHeader& header(const CommonReq* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::raybo::RegReq& reg_req(const CommonReq* msg);
  static void set_has_reg_req(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::raybo::LoginReq& login_req(const CommonReq* msg);
  static void set_has_login_req(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::raybo::LogoutReq& logout_req(const CommonReq* msg);
  static void set_has_logout_req(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::raybo::AddFriendReq& add_friend_req(const CommonReq* msg);
  static void set_has_add_friend_req(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::raybo::DelFriendReq& del_friend_req(const CommonReq* msg);
  static void set_has_del_friend_req(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::raybo::PublishMessageReq& publish_message_req(const CommonReq* msg);
  static void set_has_publish_message_req(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::raybo::GetPhotoReq& get_photo_req(const CommonReq* msg);
  static void set_has_get_photo_req(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::raybo::GetMessageListReq& get_message_list_req(const CommonReq* msg);
  static void set_has_get_message_list_req(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

const ::raybo::MsgHeader&
CommonReq::_Internal::header(const CommonReq* msg) {
  return *msg->_impl_.header_;
}
const ::raybo::RegReq&
CommonReq::_Internal::reg_req(const CommonReq* msg) {
  return *msg->_impl_.reg_req_;
}
const ::raybo::LoginReq&
CommonReq::_Internal::login_req(const CommonReq* msg) {
  return *msg->_impl_.login_req_;
}
const ::raybo::LogoutReq&
CommonReq::_Internal::logout_req(const CommonReq* msg) {
  return *msg->_impl_.logout_req_;
}
const ::raybo::AddFriendReq&
CommonReq::_Internal::add_friend_req(const CommonReq* msg) {
  return *msg->_impl_.add_friend_req_;
}
const ::raybo::DelFriendReq&
CommonReq::_Internal::del_friend_req(const CommonReq* msg) {
  return *msg->_impl_.del_friend_req_;
}
const ::raybo::PublishMessageReq&
CommonReq::_Internal::publish_message_req(const CommonReq* msg) {
  return *msg->_impl_.publish_message_req_;
}
const ::raybo::GetPhotoReq&
CommonReq::_Internal::get_photo_req(const CommonReq* msg) {
  return *msg->_impl_.get_photo_req_;
}
const ::raybo::GetMessageListReq&
CommonReq::_Internal::get_message_list_req(const CommonReq* msg) {
  return *msg->_impl_.get_message_list_req_;
}
CommonReq::CommonReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:raybo.CommonReq)
}
CommonReq::CommonReq(const CommonReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.reg_req_){nullptr}
    , decltype(_impl_.login_req_){nullptr}
    , decltype(_impl_.logout_req_){nullptr}
    , decltype(_impl_.add_friend_req_){nullptr}
    , decltype(_impl_.del_friend_req_){nullptr}
    , decltype(_impl_.publish_message_req_){nullptr}
    , decltype(_impl_.get_photo_req_){nullptr}
    , decltype(_impl_.get_message_list_req_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _impl_.header_ = new ::raybo::MsgHeader(*from._impl_.header_);
  }
  if (from._internal_has_reg_req()) {
    _impl_.reg_req_ = new ::raybo::RegReq(*from._impl_.reg_req_);
  }
  if (from._internal_has_login_req()) {
    _impl_.login_req_ = new ::raybo::LoginReq(*from._impl_.login_req_);
  }
  if (from._internal_has_logout_req()) {
    _impl_.logout_req_ = new ::raybo::LogoutReq(*from._impl_.logout_req_);
  }
  if (from._internal_has_add_friend_req()) {
    _impl_.add_friend_req_ = new ::raybo::AddFriendReq(*from._impl_.add_friend_req_);
  }
  if (from._internal_has_del_friend_req()) {
    _impl_.del_friend_req_ = new ::raybo::DelFriendReq(*from._impl_.del_friend_req_);
  }
  if (from._internal_has_publish_message_req()) {
    _impl_.publish_message_req_ = new ::raybo::PublishMessageReq(*from._impl_.publish_message_req_);
  }
  if (from._internal_has_get_photo_req()) {
    _impl_.get_photo_req_ = new ::raybo::GetPhotoReq(*from._impl_.get_photo_req_);
  }
  if (from._internal_has_get_message_list_req()) {
    _impl_.get_message_list_req_ = new ::raybo::GetMessageListReq(*from._impl_.get_message_list_req_);
  }
  // @@protoc_insertion_point(copy_constructor:raybo.CommonReq)
}

inline void CommonReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.reg_req_){nullptr}
    , decltype(_impl_.login_req_){nullptr}
    , decltype(_impl_.logout_req_){nullptr}
    , decltype(_impl_.add_friend_req_){nullptr}
    , decltype(_impl_.del_friend_req_){nullptr}
    , decltype(_impl_.publish_message_req_){nullptr}
    , decltype(_impl_.get_photo_req_){nullptr}
    , decltype(_impl_.get_message_list_req_){nullptr}
  };
}

CommonReq::~CommonReq() {
  // @@protoc_insertion_point(destructor:raybo.CommonReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommonReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
  if (this != internal_default_instance()) delete _impl_.reg_req_;
  if (this != internal_default_instance()) delete _impl_.login_req_;
  if (this != internal_default_instance()) delete _impl_.logout_req_;
  if (this != internal_default_instance()) delete _impl_.add_friend_req_;
  if (this != internal_default_instance()) delete _impl_.del_friend_req_;
  if (this != internal_default_instance()) delete _impl_.publish_message_req_;
  if (this != internal_default_instance()) delete _impl_.get_photo_req_;
  if (this != internal_default_instance()) delete _impl_.get_message_list_req_;
}

void CommonReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommonReq::Clear() {
// @@protoc_insertion_point(message_clear_start:raybo.CommonReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.header_ != nullptr);
      _impl_.header_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.reg_req_ != nullptr);
      _impl_.reg_req_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.login_req_ != nullptr);
      _impl_.login_req_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.logout_req_ != nullptr);
      _impl_.logout_req_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.add_friend_req_ != nullptr);
      _impl_.add_friend_req_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.del_friend_req_ != nullptr);
      _impl_.del_friend_req_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.publish_message_req_ != nullptr);
      _impl_.publish_message_req_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.get_photo_req_ != nullptr);
      _impl_.get_photo_req_->Clear();
    }
  }
  if (cached_has_bits & 0x00000100u) {
    GOOGLE_DCHECK(_impl_.get_message_list_req_ != nullptr);
    _impl_.get_message_list_req_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommonReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .raybo.MsgHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .raybo.RegReq reg_req = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_reg_req(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .raybo.LoginReq login_req = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_login_req(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .raybo.LogoutReq logout_req = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_logout_req(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .raybo.AddFriendReq add_friend_req = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_add_friend_req(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .raybo.DelFriendReq del_friend_req = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_del_friend_req(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .raybo.PublishMessageReq publish_message_req = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_publish_message_req(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .raybo.GetPhotoReq get_photo_req = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_get_photo_req(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .raybo.GetMessageListReq get_message_list_req = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_get_message_list_req(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommonReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:raybo.CommonReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .raybo.MsgHeader header = 1;
  if (_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // optional .raybo.RegReq reg_req = 2;
  if (_internal_has_reg_req()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::reg_req(this),
        _Internal::reg_req(this).GetCachedSize(), target, stream);
  }

  // optional .raybo.LoginReq login_req = 3;
  if (_internal_has_login_req()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::login_req(this),
        _Internal::login_req(this).GetCachedSize(), target, stream);
  }

  // optional .raybo.LogoutReq logout_req = 4;
  if (_internal_has_logout_req()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::logout_req(this),
        _Internal::logout_req(this).GetCachedSize(), target, stream);
  }

  // optional .raybo.AddFriendReq add_friend_req = 5;
  if (_internal_has_add_friend_req()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::add_friend_req(this),
        _Internal::add_friend_req(this).GetCachedSize(), target, stream);
  }

  // optional .raybo.DelFriendReq del_friend_req = 6;
  if (_internal_has_del_friend_req()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::del_friend_req(this),
        _Internal::del_friend_req(this).GetCachedSize(), target, stream);
  }

  // optional .raybo.PublishMessageReq publish_message_req = 7;
  if (_internal_has_publish_message_req()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::publish_message_req(this),
        _Internal::publish_message_req(this).GetCachedSize(), target, stream);
  }

  // optional .raybo.GetPhotoReq get_photo_req = 8;
  if (_internal_has_get_photo_req()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::get_photo_req(this),
        _Internal::get_photo_req(this).GetCachedSize(), target, stream);
  }

  // optional .raybo.GetMessageListReq get_message_list_req = 9;
  if (_internal_has_get_message_list_req()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::get_message_list_req(this),
        _Internal::get_message_list_req(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:raybo.CommonReq)
  return target;
}

size_t CommonReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:raybo.CommonReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .raybo.MsgHeader header = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.header_);
    }

    // optional .raybo.RegReq reg_req = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.reg_req_);
    }

    // optional .raybo.LoginReq login_req = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.login_req_);
    }

    // optional .raybo.LogoutReq logout_req = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.logout_req_);
    }

    // optional .raybo.AddFriendReq add_friend_req = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.add_friend_req_);
    }

    // optional .raybo.DelFriendReq del_friend_req = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.del_friend_req_);
    }

    // optional .raybo.PublishMessageReq publish_message_req = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.publish_message_req_);
    }

    // optional .raybo.GetPhotoReq get_photo_req = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.get_photo_req_);
    }

  }
  // optional .raybo.GetMessageListReq get_message_list_req = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.get_message_list_req_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommonReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommonReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommonReq::GetClassData() const { return &_class_data_; }

void CommonReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CommonReq *>(to)->MergeFrom(
      static_cast<const CommonReq &>(from));
}


void CommonReq::MergeFrom(const CommonReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:raybo.CommonReq)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_header()->::raybo::MsgHeader::MergeFrom(from._internal_header());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_reg_req()->::raybo::RegReq::MergeFrom(from._internal_reg_req());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_login_req()->::raybo::LoginReq::MergeFrom(from._internal_login_req());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_logout_req()->::raybo::LogoutReq::MergeFrom(from._internal_logout_req());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_add_friend_req()->::raybo::AddFriendReq::MergeFrom(from._internal_add_friend_req());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_del_friend_req()->::raybo::DelFriendReq::MergeFrom(from._internal_del_friend_req());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_publish_message_req()->::raybo::PublishMessageReq::MergeFrom(from._internal_publish_message_req());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_mutable_get_photo_req()->::raybo::GetPhotoReq::MergeFrom(from._internal_get_photo_req());
    }
  }
  if (cached_has_bits & 0x00000100u) {
    _internal_mutable_get_message_list_req()->::raybo::GetMessageListReq::MergeFrom(from._internal_get_message_list_req());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommonReq::CopyFrom(const CommonReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:raybo.CommonReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommonReq::IsInitialized() const {
  return true;
}

void CommonReq::InternalSwap(CommonReq* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommonReq, _impl_.get_message_list_req_)
      + sizeof(CommonReq::_impl_.get_message_list_req_)
      - PROTOBUF_FIELD_OFFSET(CommonReq, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommonReq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_message_5fdefine_2eproto_getter, &descriptor_table_message_5fdefine_2eproto_once,
      file_level_metadata_message_5fdefine_2eproto[18]);
}

// ===================================================================

class CommonRsp::_Internal {
 public:
  using HasBits = decltype(std::declval<CommonRsp>()._impl_._has_bits_);
  static const ::raybo::MsgHeader& header(const CommonRsp* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::raybo::RegRsp& reg_rsp(const CommonRsp* msg);
  static void set_has_reg_rsp(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::raybo::LoginRsp& login_rsp(const CommonRsp* msg);
  static void set_has_login_rsp(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::raybo::LogoutRsp& logout_rsp(const CommonRsp* msg);
  static void set_has_logout_rsp(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::raybo::AddFriendRsp& add_friend_rsp(const CommonRsp* msg);
  static void set_has_add_friend_rsp(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::raybo::DelFriendRsp& del_friend_rsp(const CommonRsp* msg);
  static void set_has_del_friend_rsp(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::raybo::PublishMessageRsp& publish_message_rsp(const CommonRsp* msg);
  static void set_has_publish_message_rsp(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::raybo::GetPhotoRsp& get_photo_rsp(const CommonRsp* msg);
  static void set_has_get_photo_rsp(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::raybo::GetMessageListRsp& get_message_list_rsp(const CommonRsp* msg);
  static void set_has_get_message_list_rsp(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

const ::raybo::MsgHeader&
CommonRsp::_Internal::header(const CommonRsp* msg) {
  return *msg->_impl_.header_;
}
const ::raybo::RegRsp&
CommonRsp::_Internal::reg_rsp(const CommonRsp* msg) {
  return *msg->_impl_.reg_rsp_;
}
const ::raybo::LoginRsp&
CommonRsp::_Internal::login_rsp(const CommonRsp* msg) {
  return *msg->_impl_.login_rsp_;
}
const ::raybo::LogoutRsp&
CommonRsp::_Internal::logout_rsp(const CommonRsp* msg) {
  return *msg->_impl_.logout_rsp_;
}
const ::raybo::AddFriendRsp&
CommonRsp::_Internal::add_friend_rsp(const CommonRsp* msg) {
  return *msg->_impl_.add_friend_rsp_;
}
const ::raybo::DelFriendRsp&
CommonRsp::_Internal::del_friend_rsp(const CommonRsp* msg) {
  return *msg->_impl_.del_friend_rsp_;
}
const ::raybo::PublishMessageRsp&
CommonRsp::_Internal::publish_message_rsp(const CommonRsp* msg) {
  return *msg->_impl_.publish_message_rsp_;
}
const ::raybo::GetPhotoRsp&
CommonRsp::_Internal::get_photo_rsp(const CommonRsp* msg) {
  return *msg->_impl_.get_photo_rsp_;
}
const ::raybo::GetMessageListRsp&
CommonRsp::_Internal::get_message_list_rsp(const CommonRsp* msg) {
  return *msg->_impl_.get_message_list_rsp_;
}
CommonRsp::CommonRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:raybo.CommonRsp)
}
CommonRsp::CommonRsp(const CommonRsp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.reg_rsp_){nullptr}
    , decltype(_impl_.login_rsp_){nullptr}
    , decltype(_impl_.logout_rsp_){nullptr}
    , decltype(_impl_.add_friend_rsp_){nullptr}
    , decltype(_impl_.del_friend_rsp_){nullptr}
    , decltype(_impl_.publish_message_rsp_){nullptr}
    , decltype(_impl_.get_photo_rsp_){nullptr}
    , decltype(_impl_.get_message_list_rsp_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _impl_.header_ = new ::raybo::MsgHeader(*from._impl_.header_);
  }
  if (from._internal_has_reg_rsp()) {
    _impl_.reg_rsp_ = new ::raybo::RegRsp(*from._impl_.reg_rsp_);
  }
  if (from._internal_has_login_rsp()) {
    _impl_.login_rsp_ = new ::raybo::LoginRsp(*from._impl_.login_rsp_);
  }
  if (from._internal_has_logout_rsp()) {
    _impl_.logout_rsp_ = new ::raybo::LogoutRsp(*from._impl_.logout_rsp_);
  }
  if (from._internal_has_add_friend_rsp()) {
    _impl_.add_friend_rsp_ = new ::raybo::AddFriendRsp(*from._impl_.add_friend_rsp_);
  }
  if (from._internal_has_del_friend_rsp()) {
    _impl_.del_friend_rsp_ = new ::raybo::DelFriendRsp(*from._impl_.del_friend_rsp_);
  }
  if (from._internal_has_publish_message_rsp()) {
    _impl_.publish_message_rsp_ = new ::raybo::PublishMessageRsp(*from._impl_.publish_message_rsp_);
  }
  if (from._internal_has_get_photo_rsp()) {
    _impl_.get_photo_rsp_ = new ::raybo::GetPhotoRsp(*from._impl_.get_photo_rsp_);
  }
  if (from._internal_has_get_message_list_rsp()) {
    _impl_.get_message_list_rsp_ = new ::raybo::GetMessageListRsp(*from._impl_.get_message_list_rsp_);
  }
  // @@protoc_insertion_point(copy_constructor:raybo.CommonRsp)
}

inline void CommonRsp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.reg_rsp_){nullptr}
    , decltype(_impl_.login_rsp_){nullptr}
    , decltype(_impl_.logout_rsp_){nullptr}
    , decltype(_impl_.add_friend_rsp_){nullptr}
    , decltype(_impl_.del_friend_rsp_){nullptr}
    , decltype(_impl_.publish_message_rsp_){nullptr}
    , decltype(_impl_.get_photo_rsp_){nullptr}
    , decltype(_impl_.get_message_list_rsp_){nullptr}
  };
}

CommonRsp::~CommonRsp() {
  // @@protoc_insertion_point(destructor:raybo.CommonRsp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommonRsp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
  if (this != internal_default_instance()) delete _impl_.reg_rsp_;
  if (this != internal_default_instance()) delete _impl_.login_rsp_;
  if (this != internal_default_instance()) delete _impl_.logout_rsp_;
  if (this != internal_default_instance()) delete _impl_.add_friend_rsp_;
  if (this != internal_default_instance()) delete _impl_.del_friend_rsp_;
  if (this != internal_default_instance()) delete _impl_.publish_message_rsp_;
  if (this != internal_default_instance()) delete _impl_.get_photo_rsp_;
  if (this != internal_default_instance()) delete _impl_.get_message_list_rsp_;
}

void CommonRsp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommonRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:raybo.CommonRsp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.header_ != nullptr);
      _impl_.header_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.reg_rsp_ != nullptr);
      _impl_.reg_rsp_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.login_rsp_ != nullptr);
      _impl_.login_rsp_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.logout_rsp_ != nullptr);
      _impl_.logout_rsp_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.add_friend_rsp_ != nullptr);
      _impl_.add_friend_rsp_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.del_friend_rsp_ != nullptr);
      _impl_.del_friend_rsp_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.publish_message_rsp_ != nullptr);
      _impl_.publish_message_rsp_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.get_photo_rsp_ != nullptr);
      _impl_.get_photo_rsp_->Clear();
    }
  }
  if (cached_has_bits & 0x00000100u) {
    GOOGLE_DCHECK(_impl_.get_message_list_rsp_ != nullptr);
    _impl_.get_message_list_rsp_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommonRsp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .raybo.MsgHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .raybo.RegRsp reg_rsp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_reg_rsp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .raybo.LoginRsp login_rsp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_login_rsp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .raybo.LogoutRsp logout_rsp = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_logout_rsp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .raybo.AddFriendRsp add_friend_rsp = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_add_friend_rsp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .raybo.DelFriendRsp del_friend_rsp = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_del_friend_rsp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .raybo.PublishMessageRsp publish_message_rsp = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_publish_message_rsp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .raybo.GetPhotoRsp get_photo_rsp = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_get_photo_rsp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .raybo.GetMessageListRsp get_message_list_rsp = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_get_message_list_rsp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommonRsp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:raybo.CommonRsp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .raybo.MsgHeader header = 1;
  if (_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // optional .raybo.RegRsp reg_rsp = 2;
  if (_internal_has_reg_rsp()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::reg_rsp(this),
        _Internal::reg_rsp(this).GetCachedSize(), target, stream);
  }

  // optional .raybo.LoginRsp login_rsp = 3;
  if (_internal_has_login_rsp()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::login_rsp(this),
        _Internal::login_rsp(this).GetCachedSize(), target, stream);
  }

  // optional .raybo.LogoutRsp logout_rsp = 4;
  if (_internal_has_logout_rsp()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::logout_rsp(this),
        _Internal::logout_rsp(this).GetCachedSize(), target, stream);
  }

  // optional .raybo.AddFriendRsp add_friend_rsp = 5;
  if (_internal_has_add_friend_rsp()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::add_friend_rsp(this),
        _Internal::add_friend_rsp(this).GetCachedSize(), target, stream);
  }

  // optional .raybo.DelFriendRsp del_friend_rsp = 6;
  if (_internal_has_del_friend_rsp()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::del_friend_rsp(this),
        _Internal::del_friend_rsp(this).GetCachedSize(), target, stream);
  }

  // optional .raybo.PublishMessageRsp publish_message_rsp = 7;
  if (_internal_has_publish_message_rsp()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::publish_message_rsp(this),
        _Internal::publish_message_rsp(this).GetCachedSize(), target, stream);
  }

  // optional .raybo.GetPhotoRsp get_photo_rsp = 8;
  if (_internal_has_get_photo_rsp()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::get_photo_rsp(this),
        _Internal::get_photo_rsp(this).GetCachedSize(), target, stream);
  }

  // optional .raybo.GetMessageListRsp get_message_list_rsp = 9;
  if (_internal_has_get_message_list_rsp()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::get_message_list_rsp(this),
        _Internal::get_message_list_rsp(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:raybo.CommonRsp)
  return target;
}

size_t CommonRsp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:raybo.CommonRsp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .raybo.MsgHeader header = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.header_);
    }

    // optional .raybo.RegRsp reg_rsp = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.reg_rsp_);
    }

    // optional .raybo.LoginRsp login_rsp = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.login_rsp_);
    }

    // optional .raybo.LogoutRsp logout_rsp = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.logout_rsp_);
    }

    // optional .raybo.AddFriendRsp add_friend_rsp = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.add_friend_rsp_);
    }

    // optional .raybo.DelFriendRsp del_friend_rsp = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.del_friend_rsp_);
    }

    // optional .raybo.PublishMessageRsp publish_message_rsp = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.publish_message_rsp_);
    }

    // optional .raybo.GetPhotoRsp get_photo_rsp = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.get_photo_rsp_);
    }

  }
  // optional .raybo.GetMessageListRsp get_message_list_rsp = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.get_message_list_rsp_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommonRsp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommonRsp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommonRsp::GetClassData() const { return &_class_data_; }

void CommonRsp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CommonRsp *>(to)->MergeFrom(
      static_cast<const CommonRsp &>(from));
}


void CommonRsp::MergeFrom(const CommonRsp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:raybo.CommonRsp)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_header()->::raybo::MsgHeader::MergeFrom(from._internal_header());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_reg_rsp()->::raybo::RegRsp::MergeFrom(from._internal_reg_rsp());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_login_rsp()->::raybo::LoginRsp::MergeFrom(from._internal_login_rsp());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_logout_rsp()->::raybo::LogoutRsp::MergeFrom(from._internal_logout_rsp());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_add_friend_rsp()->::raybo::AddFriendRsp::MergeFrom(from._internal_add_friend_rsp());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_del_friend_rsp()->::raybo::DelFriendRsp::MergeFrom(from._internal_del_friend_rsp());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_publish_message_rsp()->::raybo::PublishMessageRsp::MergeFrom(from._internal_publish_message_rsp());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_mutable_get_photo_rsp()->::raybo::GetPhotoRsp::MergeFrom(from._internal_get_photo_rsp());
    }
  }
  if (cached_has_bits & 0x00000100u) {
    _internal_mutable_get_message_list_rsp()->::raybo::GetMessageListRsp::MergeFrom(from._internal_get_message_list_rsp());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommonRsp::CopyFrom(const CommonRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:raybo.CommonRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommonRsp::IsInitialized() const {
  return true;
}

void CommonRsp::InternalSwap(CommonRsp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommonRsp, _impl_.get_message_list_rsp_)
      + sizeof(CommonRsp::_impl_.get_message_list_rsp_)
      - PROTOBUF_FIELD_OFFSET(CommonRsp, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommonRsp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_message_5fdefine_2eproto_getter, &descriptor_table_message_5fdefine_2eproto_once,
      file_level_metadata_message_5fdefine_2eproto[19]);
}

// ===================================================================

class GetUserIdByNameReq::_Internal {
 public:
  using HasBits = decltype(std::declval<GetUserIdByNameReq>()._impl_._has_bits_);
  static const ::raybo::MsgHeader& header(const GetUserIdByNameReq* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_user_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::raybo::MsgHeader&
GetUserIdByNameReq::_Internal::header(const GetUserIdByNameReq* msg) {
  return *msg->_impl_.header_;
}
GetUserIdByNameReq::GetUserIdByNameReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:raybo.GetUserIdByNameReq)
}
GetUserIdByNameReq::GetUserIdByNameReq(const GetUserIdByNameReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_name_){}
    , decltype(_impl_.header_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.user_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_name()) {
    _impl_.user_name_.Set(from._internal_user_name(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_header()) {
    _impl_.header_ = new ::raybo::MsgHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:raybo.GetUserIdByNameReq)
}

inline void GetUserIdByNameReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_name_){}
    , decltype(_impl_.header_){nullptr}
  };
  _impl_.user_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetUserIdByNameReq::~GetUserIdByNameReq() {
  // @@protoc_insertion_point(destructor:raybo.GetUserIdByNameReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetUserIdByNameReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.user_name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void GetUserIdByNameReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetUserIdByNameReq::Clear() {
// @@protoc_insertion_point(message_clear_start:raybo.GetUserIdByNameReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.user_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.header_ != nullptr);
      _impl_.header_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetUserIdByNameReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .raybo.MsgHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string user_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_user_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "raybo.GetUserIdByNameReq.user_name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetUserIdByNameReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:raybo.GetUserIdByNameReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .raybo.MsgHeader header = 1;
  if (_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // optional string user_name = 2;
  if (_internal_has_user_name()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_user_name().data(), static_cast<int>(this->_internal_user_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "raybo.GetUserIdByNameReq.user_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_user_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:raybo.GetUserIdByNameReq)
  return target;
}

size_t GetUserIdByNameReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:raybo.GetUserIdByNameReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string user_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_name());
    }

    // optional .raybo.MsgHeader header = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.header_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetUserIdByNameReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetUserIdByNameReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetUserIdByNameReq::GetClassData() const { return &_class_data_; }

void GetUserIdByNameReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GetUserIdByNameReq *>(to)->MergeFrom(
      static_cast<const GetUserIdByNameReq &>(from));
}


void GetUserIdByNameReq::MergeFrom(const GetUserIdByNameReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:raybo.GetUserIdByNameReq)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_user_name(from._internal_user_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_header()->::raybo::MsgHeader::MergeFrom(from._internal_header());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetUserIdByNameReq::CopyFrom(const GetUserIdByNameReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:raybo.GetUserIdByNameReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetUserIdByNameReq::IsInitialized() const {
  return true;
}

void GetUserIdByNameReq::InternalSwap(GetUserIdByNameReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_name_, lhs_arena,
      &other->_impl_.user_name_, rhs_arena
  );
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GetUserIdByNameReq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_message_5fdefine_2eproto_getter, &descriptor_table_message_5fdefine_2eproto_once,
      file_level_metadata_message_5fdefine_2eproto[20]);
}

// ===================================================================

class GetUserIdByNameRsp::_Internal {
 public:
  using HasBits = decltype(std::declval<GetUserIdByNameRsp>()._impl_._has_bits_);
  static const ::raybo::MsgHeader& header(const GetUserIdByNameRsp* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::raybo::MsgHeader&
GetUserIdByNameRsp::_Internal::header(const GetUserIdByNameRsp* msg) {
  return *msg->_impl_.header_;
}
GetUserIdByNameRsp::GetUserIdByNameRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:raybo.GetUserIdByNameRsp)
}
GetUserIdByNameRsp::GetUserIdByNameRsp(const GetUserIdByNameRsp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.ret_){}
    , decltype(_impl_.user_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _impl_.header_ = new ::raybo::MsgHeader(*from._impl_.header_);
  }
  ::memcpy(&_impl_.ret_, &from._impl_.ret_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.user_id_) -
    reinterpret_cast<char*>(&_impl_.ret_)) + sizeof(_impl_.user_id_));
  // @@protoc_insertion_point(copy_constructor:raybo.GetUserIdByNameRsp)
}

inline void GetUserIdByNameRsp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.ret_){0}
    , decltype(_impl_.user_id_){0}
  };
}

GetUserIdByNameRsp::~GetUserIdByNameRsp() {
  // @@protoc_insertion_point(destructor:raybo.GetUserIdByNameRsp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetUserIdByNameRsp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
}

void GetUserIdByNameRsp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetUserIdByNameRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:raybo.GetUserIdByNameRsp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.ret_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.user_id_) -
        reinterpret_cast<char*>(&_impl_.ret_)) + sizeof(_impl_.user_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetUserIdByNameRsp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .raybo.MsgHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ret = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ret(&has_bits);
          _impl_.ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 user_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_user_id(&has_bits);
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetUserIdByNameRsp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:raybo.GetUserIdByNameRsp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .raybo.MsgHeader header = 1;
  if (_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // optional int32 ret = 2;
  if (_internal_has_ret()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_ret(), target);
  }

  // optional int32 user_id = 3;
  if (_internal_has_user_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_user_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:raybo.GetUserIdByNameRsp)
  return target;
}

size_t GetUserIdByNameRsp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:raybo.GetUserIdByNameRsp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .raybo.MsgHeader header = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.header_);
    }

    // optional int32 ret = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ret());
    }

    // optional int32 user_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_user_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetUserIdByNameRsp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetUserIdByNameRsp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetUserIdByNameRsp::GetClassData() const { return &_class_data_; }

void GetUserIdByNameRsp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GetUserIdByNameRsp *>(to)->MergeFrom(
      static_cast<const GetUserIdByNameRsp &>(from));
}


void GetUserIdByNameRsp::MergeFrom(const GetUserIdByNameRsp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:raybo.GetUserIdByNameRsp)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_header()->::raybo::MsgHeader::MergeFrom(from._internal_header());
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.ret_ = from._impl_.ret_;
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.user_id_ = from._impl_.user_id_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetUserIdByNameRsp::CopyFrom(const GetUserIdByNameRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:raybo.GetUserIdByNameRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetUserIdByNameRsp::IsInitialized() const {
  return true;
}

void GetUserIdByNameRsp::InternalSwap(GetUserIdByNameRsp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetUserIdByNameRsp, _impl_.user_id_)
      + sizeof(GetUserIdByNameRsp::_impl_.user_id_)
      - PROTOBUF_FIELD_OFFSET(GetUserIdByNameRsp, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GetUserIdByNameRsp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_message_5fdefine_2eproto_getter, &descriptor_table_message_5fdefine_2eproto_once,
      file_level_metadata_message_5fdefine_2eproto[21]);
}

// ===================================================================

class CreateUserReq::_Internal {
 public:
  using HasBits = decltype(std::declval<CreateUserReq>()._impl_._has_bits_);
  static const ::raybo::MsgHeader& header(const CreateUserReq* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_user_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_password(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_from(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::raybo::MsgHeader&
CreateUserReq::_Internal::header(const CreateUserReq* msg) {
  return *msg->_impl_.header_;
}
CreateUserReq::CreateUserReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:raybo.CreateUserReq)
}
CreateUserReq::CreateUserReq(const CreateUserReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_name_){}
    , decltype(_impl_.password_){}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.from_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.user_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_name()) {
    _impl_.user_name_.Set(from._internal_user_name(), 
      GetArenaForAllocation());
  }
  _impl_.password_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.password_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_password()) {
    _impl_.password_.Set(from._internal_password(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_header()) {
    _impl_.header_ = new ::raybo::MsgHeader(*from._impl_.header_);
  }
  _impl_.from_ = from._impl_.from_;
  // @@protoc_insertion_point(copy_constructor:raybo.CreateUserReq)
}

inline void CreateUserReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_name_){}
    , decltype(_impl_.password_){}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.from_){0}
  };
  _impl_.user_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.password_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.password_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CreateUserReq::~CreateUserReq() {
  // @@protoc_insertion_point(destructor:raybo.CreateUserReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreateUserReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.user_name_.Destroy();
  _impl_.password_.Destroy();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void CreateUserReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CreateUserReq::Clear() {
// @@protoc_insertion_point(message_clear_start:raybo.CreateUserReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.user_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.password_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.header_ != nullptr);
      _impl_.header_->Clear();
    }
  }
  _impl_.from_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateUserReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .raybo.MsgHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string user_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_user_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "raybo.CreateUserReq.user_name"));
        } else
          goto handle_unusual;
        continue;
      // optional string password = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_password();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "raybo.CreateUserReq.password"));
        } else
          goto handle_unusual;
        continue;
      // optional int32 from = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_from(&has_bits);
          _impl_.from_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateUserReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:raybo.CreateUserReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .raybo.MsgHeader header = 1;
  if (_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // optional string user_name = 2;
  if (_internal_has_user_name()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_user_name().data(), static_cast<int>(this->_internal_user_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "raybo.CreateUserReq.user_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_user_name(), target);
  }

  // optional string password = 3;
  if (_internal_has_password()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_password().data(), static_cast<int>(this->_internal_password().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "raybo.CreateUserReq.password");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_password(), target);
  }

  // optional int32 from = 4;
  if (_internal_has_from()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_from(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:raybo.CreateUserReq)
  return target;
}

size_t CreateUserReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:raybo.CreateUserReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string user_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_name());
    }

    // optional string password = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_password());
    }

    // optional .raybo.MsgHeader header = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.header_);
    }

    // optional int32 from = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_from());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateUserReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CreateUserReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateUserReq::GetClassData() const { return &_class_data_; }

void CreateUserReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CreateUserReq *>(to)->MergeFrom(
      static_cast<const CreateUserReq &>(from));
}


void CreateUserReq::MergeFrom(const CreateUserReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:raybo.CreateUserReq)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_user_name(from._internal_user_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_password(from._internal_password());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_header()->::raybo::MsgHeader::MergeFrom(from._internal_header());
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.from_ = from._impl_.from_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateUserReq::CopyFrom(const CreateUserReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:raybo.CreateUserReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateUserReq::IsInitialized() const {
  return true;
}

void CreateUserReq::InternalSwap(CreateUserReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_name_, lhs_arena,
      &other->_impl_.user_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.password_, lhs_arena,
      &other->_impl_.password_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CreateUserReq, _impl_.from_)
      + sizeof(CreateUserReq::_impl_.from_)
      - PROTOBUF_FIELD_OFFSET(CreateUserReq, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateUserReq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_message_5fdefine_2eproto_getter, &descriptor_table_message_5fdefine_2eproto_once,
      file_level_metadata_message_5fdefine_2eproto[22]);
}

// ===================================================================

class CreateUserRsp::_Internal {
 public:
  using HasBits = decltype(std::declval<CreateUserRsp>()._impl_._has_bits_);
  static const ::raybo::MsgHeader& header(const CreateUserRsp* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::raybo::MsgHeader&
CreateUserRsp::_Internal::header(const CreateUserRsp* msg) {
  return *msg->_impl_.header_;
}
CreateUserRsp::CreateUserRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:raybo.CreateUserRsp)
}
CreateUserRsp::CreateUserRsp(const CreateUserRsp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.ret_){}
    , decltype(_impl_.user_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _impl_.header_ = new ::raybo::MsgHeader(*from._impl_.header_);
  }
  ::memcpy(&_impl_.ret_, &from._impl_.ret_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.user_id_) -
    reinterpret_cast<char*>(&_impl_.ret_)) + sizeof(_impl_.user_id_));
  // @@protoc_insertion_point(copy_constructor:raybo.CreateUserRsp)
}

inline void CreateUserRsp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.ret_){0}
    , decltype(_impl_.user_id_){0}
  };
}

CreateUserRsp::~CreateUserRsp() {
  // @@protoc_insertion_point(destructor:raybo.CreateUserRsp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreateUserRsp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
}

void CreateUserRsp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CreateUserRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:raybo.CreateUserRsp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.ret_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.user_id_) -
        reinterpret_cast<char*>(&_impl_.ret_)) + sizeof(_impl_.user_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateUserRsp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .raybo.MsgHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ret = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ret(&has_bits);
          _impl_.ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 user_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_user_id(&has_bits);
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateUserRsp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:raybo.CreateUserRsp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .raybo.MsgHeader header = 1;
  if (_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // optional int32 ret = 2;
  if (_internal_has_ret()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_ret(), target);
  }

  // optional int32 user_id = 3;
  if (_internal_has_user_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_user_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:raybo.CreateUserRsp)
  return target;
}

size_t CreateUserRsp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:raybo.CreateUserRsp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .raybo.MsgHeader header = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.header_);
    }

    // optional int32 ret = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ret());
    }

    // optional int32 user_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_user_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateUserRsp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CreateUserRsp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateUserRsp::GetClassData() const { return &_class_data_; }

void CreateUserRsp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CreateUserRsp *>(to)->MergeFrom(
      static_cast<const CreateUserRsp &>(from));
}


void CreateUserRsp::MergeFrom(const CreateUserRsp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:raybo.CreateUserRsp)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_header()->::raybo::MsgHeader::MergeFrom(from._internal_header());
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.ret_ = from._impl_.ret_;
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.user_id_ = from._impl_.user_id_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateUserRsp::CopyFrom(const CreateUserRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:raybo.CreateUserRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateUserRsp::IsInitialized() const {
  return true;
}

void CreateUserRsp::InternalSwap(CreateUserRsp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CreateUserRsp, _impl_.user_id_)
      + sizeof(CreateUserRsp::_impl_.user_id_)
      - PROTOBUF_FIELD_OFFSET(CreateUserRsp, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateUserRsp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_message_5fdefine_2eproto_getter, &descriptor_table_message_5fdefine_2eproto_once,
      file_level_metadata_message_5fdefine_2eproto[23]);
}

// ===================================================================

class LoginCheckReq::_Internal {
 public:
  using HasBits = decltype(std::declval<LoginCheckReq>()._impl_._has_bits_);
  static const ::raybo::MsgHeader& header(const LoginCheckReq* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_user_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_password(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::raybo::MsgHeader&
LoginCheckReq::_Internal::header(const LoginCheckReq* msg) {
  return *msg->_impl_.header_;
}
LoginCheckReq::LoginCheckReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:raybo.LoginCheckReq)
}
LoginCheckReq::LoginCheckReq(const LoginCheckReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_name_){}
    , decltype(_impl_.password_){}
    , decltype(_impl_.header_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.user_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_name()) {
    _impl_.user_name_.Set(from._internal_user_name(), 
      GetArenaForAllocation());
  }
  _impl_.password_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.password_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_password()) {
    _impl_.password_.Set(from._internal_password(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_header()) {
    _impl_.header_ = new ::raybo::MsgHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:raybo.LoginCheckReq)
}

inline void LoginCheckReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_name_){}
    , decltype(_impl_.password_){}
    , decltype(_impl_.header_){nullptr}
  };
  _impl_.user_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.password_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.password_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LoginCheckReq::~LoginCheckReq() {
  // @@protoc_insertion_point(destructor:raybo.LoginCheckReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoginCheckReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.user_name_.Destroy();
  _impl_.password_.Destroy();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void LoginCheckReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LoginCheckReq::Clear() {
// @@protoc_insertion_point(message_clear_start:raybo.LoginCheckReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.user_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.password_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.header_ != nullptr);
      _impl_.header_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LoginCheckReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .raybo.MsgHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string user_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_user_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "raybo.LoginCheckReq.user_name"));
        } else
          goto handle_unusual;
        continue;
      // optional string password = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_password();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "raybo.LoginCheckReq.password"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoginCheckReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:raybo.LoginCheckReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .raybo.MsgHeader header = 1;
  if (_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // optional string user_name = 2;
  if (_internal_has_user_name()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_user_name().data(), static_cast<int>(this->_internal_user_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "raybo.LoginCheckReq.user_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_user_name(), target);
  }

  // optional string password = 3;
  if (_internal_has_password()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_password().data(), static_cast<int>(this->_internal_password().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "raybo.LoginCheckReq.password");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_password(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:raybo.LoginCheckReq)
  return target;
}

size_t LoginCheckReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:raybo.LoginCheckReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string user_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_name());
    }

    // optional string password = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_password());
    }

    // optional .raybo.MsgHeader header = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.header_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LoginCheckReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LoginCheckReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LoginCheckReq::GetClassData() const { return &_class_data_; }

void LoginCheckReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LoginCheckReq *>(to)->MergeFrom(
      static_cast<const LoginCheckReq &>(from));
}


void LoginCheckReq::MergeFrom(const LoginCheckReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:raybo.LoginCheckReq)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_user_name(from._internal_user_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_password(from._internal_password());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_header()->::raybo::MsgHeader::MergeFrom(from._internal_header());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LoginCheckReq::CopyFrom(const LoginCheckReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:raybo.LoginCheckReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginCheckReq::IsInitialized() const {
  return true;
}

void LoginCheckReq::InternalSwap(LoginCheckReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_name_, lhs_arena,
      &other->_impl_.user_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.password_, lhs_arena,
      &other->_impl_.password_, rhs_arena
  );
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LoginCheckReq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_message_5fdefine_2eproto_getter, &descriptor_table_message_5fdefine_2eproto_once,
      file_level_metadata_message_5fdefine_2eproto[24]);
}

// ===================================================================

class LoginCheckRsp::_Internal {
 public:
  using HasBits = decltype(std::declval<LoginCheckRsp>()._impl_._has_bits_);
  static const ::raybo::MsgHeader& header(const LoginCheckRsp* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::raybo::MsgHeader&
LoginCheckRsp::_Internal::header(const LoginCheckRsp* msg) {
  return *msg->_impl_.header_;
}
LoginCheckRsp::LoginCheckRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:raybo.LoginCheckRsp)
}
LoginCheckRsp::LoginCheckRsp(const LoginCheckRsp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.ret_){}
    , decltype(_impl_.user_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _impl_.header_ = new ::raybo::MsgHeader(*from._impl_.header_);
  }
  ::memcpy(&_impl_.ret_, &from._impl_.ret_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.user_id_) -
    reinterpret_cast<char*>(&_impl_.ret_)) + sizeof(_impl_.user_id_));
  // @@protoc_insertion_point(copy_constructor:raybo.LoginCheckRsp)
}

inline void LoginCheckRsp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.ret_){0}
    , decltype(_impl_.user_id_){0}
  };
}

LoginCheckRsp::~LoginCheckRsp() {
  // @@protoc_insertion_point(destructor:raybo.LoginCheckRsp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoginCheckRsp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
}

void LoginCheckRsp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LoginCheckRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:raybo.LoginCheckRsp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.ret_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.user_id_) -
        reinterpret_cast<char*>(&_impl_.ret_)) + sizeof(_impl_.user_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LoginCheckRsp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .raybo.MsgHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ret = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ret(&has_bits);
          _impl_.ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 user_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_user_id(&has_bits);
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoginCheckRsp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:raybo.LoginCheckRsp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .raybo.MsgHeader header = 1;
  if (_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // optional int32 ret = 2;
  if (_internal_has_ret()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_ret(), target);
  }

  // optional int32 user_id = 3;
  if (_internal_has_user_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_user_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:raybo.LoginCheckRsp)
  return target;
}

size_t LoginCheckRsp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:raybo.LoginCheckRsp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .raybo.MsgHeader header = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.header_);
    }

    // optional int32 ret = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ret());
    }

    // optional int32 user_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_user_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LoginCheckRsp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LoginCheckRsp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LoginCheckRsp::GetClassData() const { return &_class_data_; }

void LoginCheckRsp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LoginCheckRsp *>(to)->MergeFrom(
      static_cast<const LoginCheckRsp &>(from));
}


void LoginCheckRsp::MergeFrom(const LoginCheckRsp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:raybo.LoginCheckRsp)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_header()->::raybo::MsgHeader::MergeFrom(from._internal_header());
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.ret_ = from._impl_.ret_;
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.user_id_ = from._impl_.user_id_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LoginCheckRsp::CopyFrom(const LoginCheckRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:raybo.LoginCheckRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginCheckRsp::IsInitialized() const {
  return true;
}

void LoginCheckRsp::InternalSwap(LoginCheckRsp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LoginCheckRsp, _impl_.user_id_)
      + sizeof(LoginCheckRsp::_impl_.user_id_)
      - PROTOBUF_FIELD_OFFSET(LoginCheckRsp, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LoginCheckRsp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_message_5fdefine_2eproto_getter, &descriptor_table_message_5fdefine_2eproto_once,
      file_level_metadata_message_5fdefine_2eproto[25]);
}

// ===================================================================

class CheckUserExistReq::_Internal {
 public:
  using HasBits = decltype(std::declval<CheckUserExistReq>()._impl_._has_bits_);
  static const ::raybo::MsgHeader& header(const CheckUserExistReq* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::raybo::MsgHeader&
CheckUserExistReq::_Internal::header(const CheckUserExistReq* msg) {
  return *msg->_impl_.header_;
}
CheckUserExistReq::CheckUserExistReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:raybo.CheckUserExistReq)
}
CheckUserExistReq::CheckUserExistReq(const CheckUserExistReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.user_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _impl_.header_ = new ::raybo::MsgHeader(*from._impl_.header_);
  }
  _impl_.user_id_ = from._impl_.user_id_;
  // @@protoc_insertion_point(copy_constructor:raybo.CheckUserExistReq)
}

inline void CheckUserExistReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.user_id_){0}
  };
}

CheckUserExistReq::~CheckUserExistReq() {
  // @@protoc_insertion_point(destructor:raybo.CheckUserExistReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CheckUserExistReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
}

void CheckUserExistReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CheckUserExistReq::Clear() {
// @@protoc_insertion_point(message_clear_start:raybo.CheckUserExistReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_.user_id_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CheckUserExistReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .raybo.MsgHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 user_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_user_id(&has_bits);
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CheckUserExistReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:raybo.CheckUserExistReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .raybo.MsgHeader header = 1;
  if (_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // optional int32 user_id = 2;
  if (_internal_has_user_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_user_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:raybo.CheckUserExistReq)
  return target;
}

size_t CheckUserExistReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:raybo.CheckUserExistReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .raybo.MsgHeader header = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.header_);
    }

    // optional int32 user_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_user_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CheckUserExistReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CheckUserExistReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CheckUserExistReq::GetClassData() const { return &_class_data_; }

void CheckUserExistReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CheckUserExistReq *>(to)->MergeFrom(
      static_cast<const CheckUserExistReq &>(from));
}


void CheckUserExistReq::MergeFrom(const CheckUserExistReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:raybo.CheckUserExistReq)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_header()->::raybo::MsgHeader::MergeFrom(from._internal_header());
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.user_id_ = from._impl_.user_id_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CheckUserExistReq::CopyFrom(const CheckUserExistReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:raybo.CheckUserExistReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckUserExistReq::IsInitialized() const {
  return true;
}

void CheckUserExistReq::InternalSwap(CheckUserExistReq* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CheckUserExistReq, _impl_.user_id_)
      + sizeof(CheckUserExistReq::_impl_.user_id_)
      - PROTOBUF_FIELD_OFFSET(CheckUserExistReq, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CheckUserExistReq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_message_5fdefine_2eproto_getter, &descriptor_table_message_5fdefine_2eproto_once,
      file_level_metadata_message_5fdefine_2eproto[26]);
}

// ===================================================================

class CheckUserExistRsp::_Internal {
 public:
  using HasBits = decltype(std::declval<CheckUserExistRsp>()._impl_._has_bits_);
  static const ::raybo::MsgHeader& header(const CheckUserExistRsp* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::raybo::MsgHeader&
CheckUserExistRsp::_Internal::header(const CheckUserExistRsp* msg) {
  return *msg->_impl_.header_;
}
CheckUserExistRsp::CheckUserExistRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:raybo.CheckUserExistRsp)
}
CheckUserExistRsp::CheckUserExistRsp(const CheckUserExistRsp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.ret_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _impl_.header_ = new ::raybo::MsgHeader(*from._impl_.header_);
  }
  _impl_.ret_ = from._impl_.ret_;
  // @@protoc_insertion_point(copy_constructor:raybo.CheckUserExistRsp)
}

inline void CheckUserExistRsp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.ret_){0}
  };
}

CheckUserExistRsp::~CheckUserExistRsp() {
  // @@protoc_insertion_point(destructor:raybo.CheckUserExistRsp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CheckUserExistRsp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
}

void CheckUserExistRsp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CheckUserExistRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:raybo.CheckUserExistRsp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_.ret_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CheckUserExistRsp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .raybo.MsgHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ret = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ret(&has_bits);
          _impl_.ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CheckUserExistRsp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:raybo.CheckUserExistRsp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .raybo.MsgHeader header = 1;
  if (_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // optional int32 ret = 2;
  if (_internal_has_ret()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_ret(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:raybo.CheckUserExistRsp)
  return target;
}

size_t CheckUserExistRsp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:raybo.CheckUserExistRsp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .raybo.MsgHeader header = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.header_);
    }

    // optional int32 ret = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ret());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CheckUserExistRsp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CheckUserExistRsp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CheckUserExistRsp::GetClassData() const { return &_class_data_; }

void CheckUserExistRsp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CheckUserExistRsp *>(to)->MergeFrom(
      static_cast<const CheckUserExistRsp &>(from));
}


void CheckUserExistRsp::MergeFrom(const CheckUserExistRsp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:raybo.CheckUserExistRsp)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_header()->::raybo::MsgHeader::MergeFrom(from._internal_header());
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.ret_ = from._impl_.ret_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CheckUserExistRsp::CopyFrom(const CheckUserExistRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:raybo.CheckUserExistRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckUserExistRsp::IsInitialized() const {
  return true;
}

void CheckUserExistRsp::InternalSwap(CheckUserExistRsp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CheckUserExistRsp, _impl_.ret_)
      + sizeof(CheckUserExistRsp::_impl_.ret_)
      - PROTOBUF_FIELD_OFFSET(CheckUserExistRsp, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CheckUserExistRsp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_message_5fdefine_2eproto_getter, &descriptor_table_message_5fdefine_2eproto_once,
      file_level_metadata_message_5fdefine_2eproto[27]);
}

// ===================================================================

class ServerToUserReq::_Internal {
 public:
  using HasBits = decltype(std::declval<ServerToUserReq>()._impl_._has_bits_);
  static const ::raybo::MsgHeader& header(const ServerToUserReq* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::raybo::GetUserIdByNameReq& get_user_id(const ServerToUserReq* msg);
  static void set_has_get_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::raybo::CreateUserReq& create_user(const ServerToUserReq* msg);
  static void set_has_create_user(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::raybo::LoginCheckReq& login_check(const ServerToUserReq* msg);
  static void set_has_login_check(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::raybo::CheckUserExistReq& check_user_exist(const ServerToUserReq* msg);
  static void set_has_check_user_exist(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::raybo::MsgHeader&
ServerToUserReq::_Internal::header(const ServerToUserReq* msg) {
  return *msg->_impl_.header_;
}
const ::raybo::GetUserIdByNameReq&
ServerToUserReq::_Internal::get_user_id(const ServerToUserReq* msg) {
  return *msg->_impl_.get_user_id_;
}
const ::raybo::CreateUserReq&
ServerToUserReq::_Internal::create_user(const ServerToUserReq* msg) {
  return *msg->_impl_.create_user_;
}
const ::raybo::LoginCheckReq&
ServerToUserReq::_Internal::login_check(const ServerToUserReq* msg) {
  return *msg->_impl_.login_check_;
}
const ::raybo::CheckUserExistReq&
ServerToUserReq::_Internal::check_user_exist(const ServerToUserReq* msg) {
  return *msg->_impl_.check_user_exist_;
}
ServerToUserReq::ServerToUserReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:raybo.ServerToUserReq)
}
ServerToUserReq::ServerToUserReq(const ServerToUserReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.get_user_id_){nullptr}
    , decltype(_impl_.create_user_){nullptr}
    , decltype(_impl_.login_check_){nullptr}
    , decltype(_impl_.check_user_exist_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _impl_.header_ = new ::raybo::MsgHeader(*from._impl_.header_);
  }
  if (from._internal_has_get_user_id()) {
    _impl_.get_user_id_ = new ::raybo::GetUserIdByNameReq(*from._impl_.get_user_id_);
  }
  if (from._internal_has_create_user()) {
    _impl_.create_user_ = new ::raybo::CreateUserReq(*from._impl_.create_user_);
  }
  if (from._internal_has_login_check()) {
    _impl_.login_check_ = new ::raybo::LoginCheckReq(*from._impl_.login_check_);
  }
  if (from._internal_has_check_user_exist()) {
    _impl_.check_user_exist_ = new ::raybo::CheckUserExistReq(*from._impl_.check_user_exist_);
  }
  // @@protoc_insertion_point(copy_constructor:raybo.ServerToUserReq)
}

inline void ServerToUserReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.get_user_id_){nullptr}
    , decltype(_impl_.create_user_){nullptr}
    , decltype(_impl_.login_check_){nullptr}
    , decltype(_impl_.check_user_exist_){nullptr}
  };
}

ServerToUserReq::~ServerToUserReq() {
  // @@protoc_insertion_point(destructor:raybo.ServerToUserReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ServerToUserReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
  if (this != internal_default_instance()) delete _impl_.get_user_id_;
  if (this != internal_default_instance()) delete _impl_.create_user_;
  if (this != internal_default_instance()) delete _impl_.login_check_;
  if (this != internal_default_instance()) delete _impl_.check_user_exist_;
}

void ServerToUserReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ServerToUserReq::Clear() {
// @@protoc_insertion_point(message_clear_start:raybo.ServerToUserReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.header_ != nullptr);
      _impl_.header_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.get_user_id_ != nullptr);
      _impl_.get_user_id_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.create_user_ != nullptr);
      _impl_.create_user_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.login_check_ != nullptr);
      _impl_.login_check_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.check_user_exist_ != nullptr);
      _impl_.check_user_exist_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ServerToUserReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .raybo.MsgHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .raybo.GetUserIdByNameReq get_user_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_get_user_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .raybo.CreateUserReq create_user = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_create_user(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .raybo.LoginCheckReq login_check = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_login_check(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .raybo.CheckUserExistReq check_user_exist = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_check_user_exist(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ServerToUserReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:raybo.ServerToUserReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .raybo.MsgHeader header = 1;
  if (_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // optional .raybo.GetUserIdByNameReq get_user_id = 2;
  if (_internal_has_get_user_id()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::get_user_id(this),
        _Internal::get_user_id(this).GetCachedSize(), target, stream);
  }

  // optional .raybo.CreateUserReq create_user = 3;
  if (_internal_has_create_user()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::create_user(this),
        _Internal::create_user(this).GetCachedSize(), target, stream);
  }

  // optional .raybo.LoginCheckReq login_check = 4;
  if (_internal_has_login_check()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::login_check(this),
        _Internal::login_check(this).GetCachedSize(), target, stream);
  }

  // optional .raybo.CheckUserExistReq check_user_exist = 5;
  if (_internal_has_check_user_exist()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::check_user_exist(this),
        _Internal::check_user_exist(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:raybo.ServerToUserReq)
  return target;
}

size_t ServerToUserReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:raybo.ServerToUserReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .raybo.MsgHeader header = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.header_);
    }

    // optional .raybo.GetUserIdByNameReq get_user_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.get_user_id_);
    }

    // optional .raybo.CreateUserReq create_user = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.create_user_);
    }

    // optional .raybo.LoginCheckReq login_check = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.login_check_);
    }

    // optional .raybo.CheckUserExistReq check_user_exist = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.check_user_exist_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ServerToUserReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ServerToUserReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ServerToUserReq::GetClassData() const { return &_class_data_; }

void ServerToUserReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ServerToUserReq *>(to)->MergeFrom(
      static_cast<const ServerToUserReq &>(from));
}


void ServerToUserReq::MergeFrom(const ServerToUserReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:raybo.ServerToUserReq)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_header()->::raybo::MsgHeader::MergeFrom(from._internal_header());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_get_user_id()->::raybo::GetUserIdByNameReq::MergeFrom(from._internal_get_user_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_create_user()->::raybo::CreateUserReq::MergeFrom(from._internal_create_user());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_login_check()->::raybo::LoginCheckReq::MergeFrom(from._internal_login_check());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_check_user_exist()->::raybo::CheckUserExistReq::MergeFrom(from._internal_check_user_exist());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ServerToUserReq::CopyFrom(const ServerToUserReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:raybo.ServerToUserReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServerToUserReq::IsInitialized() const {
  return true;
}

void ServerToUserReq::InternalSwap(ServerToUserReq* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ServerToUserReq, _impl_.check_user_exist_)
      + sizeof(ServerToUserReq::_impl_.check_user_exist_)
      - PROTOBUF_FIELD_OFFSET(ServerToUserReq, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ServerToUserReq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_message_5fdefine_2eproto_getter, &descriptor_table_message_5fdefine_2eproto_once,
      file_level_metadata_message_5fdefine_2eproto[28]);
}

// ===================================================================

class UserToServerRsp::_Internal {
 public:
  using HasBits = decltype(std::declval<UserToServerRsp>()._impl_._has_bits_);
  static const ::raybo::MsgHeader& header(const UserToServerRsp* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::raybo::GetUserIdByNameRsp& get_user_id(const UserToServerRsp* msg);
  static void set_has_get_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::raybo::CreateUserRsp& create_user(const UserToServerRsp* msg);
  static void set_has_create_user(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::raybo::LoginCheckRsp& login_check(const UserToServerRsp* msg);
  static void set_has_login_check(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::raybo::CheckUserExistRsp& check_user_exist(const UserToServerRsp* msg);
  static void set_has_check_user_exist(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::raybo::MsgHeader&
UserToServerRsp::_Internal::header(const UserToServerRsp* msg) {
  return *msg->_impl_.header_;
}
const ::raybo::GetUserIdByNameRsp&
UserToServerRsp::_Internal::get_user_id(const UserToServerRsp* msg) {
  return *msg->_impl_.get_user_id_;
}
const ::raybo::CreateUserRsp&
UserToServerRsp::_Internal::create_user(const UserToServerRsp* msg) {
  return *msg->_impl_.create_user_;
}
const ::raybo::LoginCheckRsp&
UserToServerRsp::_Internal::login_check(const UserToServerRsp* msg) {
  return *msg->_impl_.login_check_;
}
const ::raybo::CheckUserExistRsp&
UserToServerRsp::_Internal::check_user_exist(const UserToServerRsp* msg) {
  return *msg->_impl_.check_user_exist_;
}
UserToServerRsp::UserToServerRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:raybo.UserToServerRsp)
}
UserToServerRsp::UserToServerRsp(const UserToServerRsp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.get_user_id_){nullptr}
    , decltype(_impl_.create_user_){nullptr}
    , decltype(_impl_.login_check_){nullptr}
    , decltype(_impl_.check_user_exist_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _impl_.header_ = new ::raybo::MsgHeader(*from._impl_.header_);
  }
  if (from._internal_has_get_user_id()) {
    _impl_.get_user_id_ = new ::raybo::GetUserIdByNameRsp(*from._impl_.get_user_id_);
  }
  if (from._internal_has_create_user()) {
    _impl_.create_user_ = new ::raybo::CreateUserRsp(*from._impl_.create_user_);
  }
  if (from._internal_has_login_check()) {
    _impl_.login_check_ = new ::raybo::LoginCheckRsp(*from._impl_.login_check_);
  }
  if (from._internal_has_check_user_exist()) {
    _impl_.check_user_exist_ = new ::raybo::CheckUserExistRsp(*from._impl_.check_user_exist_);
  }
  // @@protoc_insertion_point(copy_constructor:raybo.UserToServerRsp)
}

inline void UserToServerRsp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.get_user_id_){nullptr}
    , decltype(_impl_.create_user_){nullptr}
    , decltype(_impl_.login_check_){nullptr}
    , decltype(_impl_.check_user_exist_){nullptr}
  };
}

UserToServerRsp::~UserToServerRsp() {
  // @@protoc_insertion_point(destructor:raybo.UserToServerRsp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UserToServerRsp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
  if (this != internal_default_instance()) delete _impl_.get_user_id_;
  if (this != internal_default_instance()) delete _impl_.create_user_;
  if (this != internal_default_instance()) delete _impl_.login_check_;
  if (this != internal_default_instance()) delete _impl_.check_user_exist_;
}

void UserToServerRsp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UserToServerRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:raybo.UserToServerRsp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.header_ != nullptr);
      _impl_.header_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.get_user_id_ != nullptr);
      _impl_.get_user_id_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.create_user_ != nullptr);
      _impl_.create_user_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.login_check_ != nullptr);
      _impl_.login_check_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.check_user_exist_ != nullptr);
      _impl_.check_user_exist_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UserToServerRsp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .raybo.MsgHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .raybo.GetUserIdByNameRsp get_user_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_get_user_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .raybo.CreateUserRsp create_user = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_create_user(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .raybo.LoginCheckRsp login_check = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_login_check(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .raybo.CheckUserExistRsp check_user_exist = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_check_user_exist(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserToServerRsp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:raybo.UserToServerRsp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .raybo.MsgHeader header = 1;
  if (_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // optional .raybo.GetUserIdByNameRsp get_user_id = 2;
  if (_internal_has_get_user_id()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::get_user_id(this),
        _Internal::get_user_id(this).GetCachedSize(), target, stream);
  }

  // optional .raybo.CreateUserRsp create_user = 3;
  if (_internal_has_create_user()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::create_user(this),
        _Internal::create_user(this).GetCachedSize(), target, stream);
  }

  // optional .raybo.LoginCheckRsp login_check = 4;
  if (_internal_has_login_check()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::login_check(this),
        _Internal::login_check(this).GetCachedSize(), target, stream);
  }

  // optional .raybo.CheckUserExistRsp check_user_exist = 5;
  if (_internal_has_check_user_exist()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::check_user_exist(this),
        _Internal::check_user_exist(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:raybo.UserToServerRsp)
  return target;
}

size_t UserToServerRsp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:raybo.UserToServerRsp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .raybo.MsgHeader header = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.header_);
    }

    // optional .raybo.GetUserIdByNameRsp get_user_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.get_user_id_);
    }

    // optional .raybo.CreateUserRsp create_user = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.create_user_);
    }

    // optional .raybo.LoginCheckRsp login_check = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.login_check_);
    }

    // optional .raybo.CheckUserExistRsp check_user_exist = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.check_user_exist_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UserToServerRsp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UserToServerRsp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UserToServerRsp::GetClassData() const { return &_class_data_; }

void UserToServerRsp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<UserToServerRsp *>(to)->MergeFrom(
      static_cast<const UserToServerRsp &>(from));
}


void UserToServerRsp::MergeFrom(const UserToServerRsp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:raybo.UserToServerRsp)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_header()->::raybo::MsgHeader::MergeFrom(from._internal_header());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_get_user_id()->::raybo::GetUserIdByNameRsp::MergeFrom(from._internal_get_user_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_create_user()->::raybo::CreateUserRsp::MergeFrom(from._internal_create_user());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_login_check()->::raybo::LoginCheckRsp::MergeFrom(from._internal_login_check());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_check_user_exist()->::raybo::CheckUserExistRsp::MergeFrom(from._internal_check_user_exist());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UserToServerRsp::CopyFrom(const UserToServerRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:raybo.UserToServerRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserToServerRsp::IsInitialized() const {
  return true;
}

void UserToServerRsp::InternalSwap(UserToServerRsp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UserToServerRsp, _impl_.check_user_exist_)
      + sizeof(UserToServerRsp::_impl_.check_user_exist_)
      - PROTOBUF_FIELD_OFFSET(UserToServerRsp, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UserToServerRsp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_message_5fdefine_2eproto_getter, &descriptor_table_message_5fdefine_2eproto_once,
      file_level_metadata_message_5fdefine_2eproto[29]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace raybo
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::raybo::MsgHeader*
Arena::CreateMaybeMessage< ::raybo::MsgHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::raybo::MsgHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::raybo::RegReq*
Arena::CreateMaybeMessage< ::raybo::RegReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::raybo::RegReq >(arena);
}
template<> PROTOBUF_NOINLINE ::raybo::RegRsp*
Arena::CreateMaybeMessage< ::raybo::RegRsp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::raybo::RegRsp >(arena);
}
template<> PROTOBUF_NOINLINE ::raybo::LoginReq*
Arena::CreateMaybeMessage< ::raybo::LoginReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::raybo::LoginReq >(arena);
}
template<> PROTOBUF_NOINLINE ::raybo::LoginRsp*
Arena::CreateMaybeMessage< ::raybo::LoginRsp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::raybo::LoginRsp >(arena);
}
template<> PROTOBUF_NOINLINE ::raybo::LogoutReq*
Arena::CreateMaybeMessage< ::raybo::LogoutReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::raybo::LogoutReq >(arena);
}
template<> PROTOBUF_NOINLINE ::raybo::LogoutRsp*
Arena::CreateMaybeMessage< ::raybo::LogoutRsp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::raybo::LogoutRsp >(arena);
}
template<> PROTOBUF_NOINLINE ::raybo::AddFriendReq*
Arena::CreateMaybeMessage< ::raybo::AddFriendReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::raybo::AddFriendReq >(arena);
}
template<> PROTOBUF_NOINLINE ::raybo::AddFriendRsp*
Arena::CreateMaybeMessage< ::raybo::AddFriendRsp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::raybo::AddFriendRsp >(arena);
}
template<> PROTOBUF_NOINLINE ::raybo::DelFriendReq*
Arena::CreateMaybeMessage< ::raybo::DelFriendReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::raybo::DelFriendReq >(arena);
}
template<> PROTOBUF_NOINLINE ::raybo::DelFriendRsp*
Arena::CreateMaybeMessage< ::raybo::DelFriendRsp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::raybo::DelFriendRsp >(arena);
}
template<> PROTOBUF_NOINLINE ::raybo::PublishMessageReq*
Arena::CreateMaybeMessage< ::raybo::PublishMessageReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::raybo::PublishMessageReq >(arena);
}
template<> PROTOBUF_NOINLINE ::raybo::PublishMessageRsp*
Arena::CreateMaybeMessage< ::raybo::PublishMessageRsp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::raybo::PublishMessageRsp >(arena);
}
template<> PROTOBUF_NOINLINE ::raybo::GetMessageListReq*
Arena::CreateMaybeMessage< ::raybo::GetMessageListReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::raybo::GetMessageListReq >(arena);
}
template<> PROTOBUF_NOINLINE ::raybo::MessageItem*
Arena::CreateMaybeMessage< ::raybo::MessageItem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::raybo::MessageItem >(arena);
}
template<> PROTOBUF_NOINLINE ::raybo::GetMessageListRsp*
Arena::CreateMaybeMessage< ::raybo::GetMessageListRsp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::raybo::GetMessageListRsp >(arena);
}
template<> PROTOBUF_NOINLINE ::raybo::GetPhotoReq*
Arena::CreateMaybeMessage< ::raybo::GetPhotoReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::raybo::GetPhotoReq >(arena);
}
template<> PROTOBUF_NOINLINE ::raybo::GetPhotoRsp*
Arena::CreateMaybeMessage< ::raybo::GetPhotoRsp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::raybo::GetPhotoRsp >(arena);
}
template<> PROTOBUF_NOINLINE ::raybo::CommonReq*
Arena::CreateMaybeMessage< ::raybo::CommonReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::raybo::CommonReq >(arena);
}
template<> PROTOBUF_NOINLINE ::raybo::CommonRsp*
Arena::CreateMaybeMessage< ::raybo::CommonRsp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::raybo::CommonRsp >(arena);
}
template<> PROTOBUF_NOINLINE ::raybo::GetUserIdByNameReq*
Arena::CreateMaybeMessage< ::raybo::GetUserIdByNameReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::raybo::GetUserIdByNameReq >(arena);
}
template<> PROTOBUF_NOINLINE ::raybo::GetUserIdByNameRsp*
Arena::CreateMaybeMessage< ::raybo::GetUserIdByNameRsp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::raybo::GetUserIdByNameRsp >(arena);
}
template<> PROTOBUF_NOINLINE ::raybo::CreateUserReq*
Arena::CreateMaybeMessage< ::raybo::CreateUserReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::raybo::CreateUserReq >(arena);
}
template<> PROTOBUF_NOINLINE ::raybo::CreateUserRsp*
Arena::CreateMaybeMessage< ::raybo::CreateUserRsp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::raybo::CreateUserRsp >(arena);
}
template<> PROTOBUF_NOINLINE ::raybo::LoginCheckReq*
Arena::CreateMaybeMessage< ::raybo::LoginCheckReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::raybo::LoginCheckReq >(arena);
}
template<> PROTOBUF_NOINLINE ::raybo::LoginCheckRsp*
Arena::CreateMaybeMessage< ::raybo::LoginCheckRsp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::raybo::LoginCheckRsp >(arena);
}
template<> PROTOBUF_NOINLINE ::raybo::CheckUserExistReq*
Arena::CreateMaybeMessage< ::raybo::CheckUserExistReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::raybo::CheckUserExistReq >(arena);
}
template<> PROTOBUF_NOINLINE ::raybo::CheckUserExistRsp*
Arena::CreateMaybeMessage< ::raybo::CheckUserExistRsp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::raybo::CheckUserExistRsp >(arena);
}
template<> PROTOBUF_NOINLINE ::raybo::ServerToUserReq*
Arena::CreateMaybeMessage< ::raybo::ServerToUserReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::raybo::ServerToUserReq >(arena);
}
template<> PROTOBUF_NOINLINE ::raybo::UserToServerRsp*
Arena::CreateMaybeMessage< ::raybo::UserToServerRsp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::raybo::UserToServerRsp >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
